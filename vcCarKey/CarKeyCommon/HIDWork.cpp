#include "stdafx.h"
#include "HIDWork.h"
#include "CommFunc.h"
#include "InteractionData.h"
#include "PassCalc.h"
#ifdef CarKey2
#include ".\..\CarKey2\CarKey2\resource.h"
#else
#include ".\..\CarKey3\CarKey3\resource.h"
#endif
#include "..\CarKey3\CarKey3\InputPSW.h"
#include "..\CarKey3\CarKey3\CarKey3.h"
#include "VMProtectSDK.h"

CHIDWork::CHIDWork(void)
{
}


CHIDWork::~CHIDWork(void)
{
}
byte* CHIDWork::KeyData_UartReadPSW(int type, int mode,CProgressCtrl* pProgress,CInteractionData* pResult/*,CStatusBarCtrl* pStatusBar*/)
{
	// TODO: Add your control notification handler code here
	unsigned int i;
	int m=0;
	unsigned char DTrd[0x03][0x10];

	byte ut_RD[0x18][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x19,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00--

		{0x01,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01},//01--发A0    --收50并比较
		{0x01,0xA1,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//02--发A1,03 --收03并比较

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01},//03--上电后等待接收红外数据
		{0x03,0x7A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//04--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//05--掉电后延时
		{0x01,0xA4,0x01,0x07,0xD0,0xD9,0xCF,0x07,0xD0,0x6D,0x60,0x00,0x00,0x0A,0x06,0x01},//06--握手配置
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01},//07--上电后等待接收红外数据

		{0x04,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x00},//08--发红外8字节,下位机自动校验接收

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00},//09--掉电后延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x01},//0A--上电后等待接收红外数据
		{0x0D,0x7A,0x31,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x01},//0B--发红外8字节，然后收一组红外数据

	//	{0x03,0x7A,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//0B--发红外8字节，然后收一组红外数据
	//	{0x03,0x7A,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//0C--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//0C--掉电后延时
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//0D--掉电后延时
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//0E--掉电后延时
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//0F--掉电后延时
		//---
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01},//10--上电后等待接收红外数据
		{0x03,0xBE,0xEE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xFF,0x01},//11--发红外8字节，然后收一组红外数据

		{0x0C,0xEB,0xEB,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x0A,0x00,0x01},//12--//数据转换
		{0x0D,0xEB,0xEB,0x00,0x9B,0x5F,0xEF,0x06,0xA6,0x2E,0x54,0x00,0x00,0x0A,0xFF,0x01},//13--发红外8字节，然后收一组红外数据

		{0x03,0xBE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xFF,0x01},//14--发红外8字节，然后收一组红外数据
	//	{0x03,0xBE,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//15--发红外8字节，然后收一组红外数据
	//	{0x03,0xBE,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//16--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//15--掉电后延时
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//16--掉电后延时

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//17--掉电后延时
	};
//	const unsigned char IRS[0x04]={0xFF,0x00,0x00,0x00};
//	const unsigned char RT[0x04]={0x01,0x03,0x03,0x03};

	bool fBsel=false;//false is IR mode, true is PCB mode,
	unsigned char Ssel=0x00;
	bool fm35=false;//false is 35mode ,true is 37mode

	unsigned int tyct=0;

	unsigned char P;
	unsigned int cntR=0x00;
	unsigned char k=0;
	unsigned int cntT=0x00;
//	unsigned int cntQ=0x00;
//	unsigned int cntD=0x00;//重试的时候掉电延时的计数

	unsigned char tptx[0x10],tprx[0x10];

	//unsigned char mode;//k;

	if(0x00==type)
	{
		fBsel = false;//IR MODE
	}
	else
	{
		fBsel = true;
	}

	//if(true==fBsel)
	//{
	//	mode=((CComboBox*)GetDlgItem(IDC_COMBO1))->GetCurSel();//后面通过选择框控制
	//	if(mode>0x03)//后续开发通过复选框控制模式,应该是PCB模式下再检查此值
	//	{
	//		MessageBox("选择未实现!!","Error",MB_OK);
	//		return;
	//	}//后续开发可删掉
	//}
	if(false==fBsel)
	{
		ut_RD[0x00][0x06]=0x00;
		ut_RD[0x00][0x07]=0xFF;
	}
	else//pcb
	{
		ut_RD[0x00][0x06]=0xFF;//IRS[mode];
		ut_RD[0x00][0x07]=0x00;

		//ut_RD[0x02][0x02]=RT[mode];
	}	
	//--//--P 可用作进度条变量
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	unsigned char y=0x00;
	P=0x00;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x16);
	pProgress->SetPos(0);
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x16;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		if(0x0B==P)
		{
			ut_RD[0x0B][0x02]=0x31+k;
		}
		if(0x14==P)
		{
			ut_RD[0x14][0x02]=0x00+k;
		}
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=ut_RD[P][i];
			tptx[i]=ut_RD[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{

		}
		for(i=0;i<0x10;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
				case 0x00://此包是配置数据，
					if(false==fBsel)//IR MODE
					{
						fAdd=false;//无需递增
						P=0x10;
					}
					break;
				//------
				case 0x05://掉电后延时
				case 0x09://掉电后延时
					//fAdd=false;//无需递增
					//P=0x09;
					break;
				//------
				case 0x01://发A0    --收50并比较
					if(0x50 != tprx[0x01])
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
// 						DspRead="uart error0";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				case 0x02://发A1,03 --收03并比较
					if(tptx[0x02] != tprx[0x01])
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
// 						DspRead="uart error1";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				//------
				case 0x03://上电后等待接收红外数据

					break;
				//------
				case 0x04://发红外8字节，然后收一组红外数据
					if(0x57!=tprx[3])
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
// 						DspRead="非57版本遥控";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				//------
				case 0x06://握手配置
					if(tptx[0x0A] != tprx[0x01])
					{
						fAdd=false;//无需递增
						P=0x17;
						//fSTP=true;//跳出循环
// 						DspRead="uart error2";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				//------
				case 0x07://上电后等待接收红外数据
					cntR++;
					if(cntR>0x80)
					{
						fAdd=false;//无需递增
						P=0x17;
						//fSTP=true;//跳出循环
// 						DspRead="uart error3";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					else
					{
						fAdd=false;//无需递增
						P=0x05;
					}
					break;
				//------
				case 0x08://发红外8字节，然后收一组红外数据

					break;
				//------
				case 0x0A://发红外8字节，然后收一组红外数据
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error4";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x0B://发红外8字节，然后收一组红外数据
				//case 0x0C://发红外8字节，然后收一组红外数据
					for(i=0;i<0x10;i++)
					{
						DTrd[k][i]=tprx[i];
					}
					k++;
					if(k>=0x03)
					{
						fOK=true;
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
					}
					else
					{
						fAdd=false;//无需递增
						P=0x09;
					}
					break;
				//------
				case 0x0C:
				case 0x17:
					fAdd=false;//无需递增
					fSTP=true;//跳出循环
					break;
				//------
				//------
				//------
				case 0x10:
					if(0x33==tprx[1])
					{
						fAdd=false;//无需递增
						cntT++;
						if(cntT>0x80)
						{
							P=0x17;
// 							DspRead="遥控异常";//错误退出
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						}
					}
					else
					{
					}
					break;
				//------
				case 0x11:
					if((0xEE==tprx[1])&&(0xBE==tprx[2]))
					{
						for(i=0;i<0x08;i++)
						{
							ut_RD[0x12][0x03+i]=tprx[3+i];
						}
					}
					else
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
// 						DspRead="uart IR error4";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				//------
				case 0x12://数据转换
					for(i=0;i<0x08;i++)
					{
						ut_RD[0x13][0x03+i]=tprx[3+i];
					}
					break;
				//------
				case 0x13://发红外8字节，然后收一组红外数据
					if((0xEE==tprx[1])&&(0xEE==tprx[2]))
					{
					}
					else
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
// 						DspRead="uart IR error5";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					break;
				//------
				case 0x14://发红外8字节，然后收一组红外数据
					for(i=0;i<0x10;i++)
					{
						DTrd[k][i]=tprx[i];
					}
					k++;
					if(k>=0x03)
					{
						fOK=true;
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x17;
					}
					else
					{
						fAdd=false;//无需递增
						//P=0x09;
					}
					break;
				//------
				default:
					fAdd=false;//无需递增
					fSTP=true;//跳出循环
// 					DspRead="异常错误2!!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
				case 0x00://此包是配置数据，不可能出错
				case 0x05://掉电后延时
				case 0x06://握手配置
				case 0x09://掉电后延时
				case 0x0D://掉电后延时
				case 0x12://数据转换
					fAdd=false;//无需递增
					fSTP=true;//跳出循环
// 					DspRead="异常错误1!!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x01://发A0    --收50并比较
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart cfg error0";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x02://发A1,03 --收03并比较
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart cfg error1";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x03://上电后等待接收红外数据
					break;
				//------
				case 0x04://发红外8字节，然后收一组红外数据
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error1";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x07://上电后等待接收红外数据
					break;
				//------
				case 0x08://发红外8字节，然后收一组红外数据
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error2";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x0A://上电后等待接收红外数据
					break;
				//------
				//case 0x0A://发红外8字节，然后收一组红外数据
				case 0x0B://发红外8字节，然后收一组红外数据
			//	case 0x0C://发红外8字节，然后收一组红外数据
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error3";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------

				//------
				//------
				//------
				//------
				case 0x10:
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="遥控器为空!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x11:
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error4-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x13:
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error5-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x14:
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x17;
// 					DspRead="uart IR error6-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
				case 0x17:
					fAdd=false;//无需递增
					fSTP=true;//跳出循环
					break;
				//------
				default:
					fOK=false;
					fAdd=false;//无需递增
					fSTP=true;//跳出循环
// 					DspRead="异常错误2!!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					break;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x17)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
			//------------------
	}
	//------------------
	if(true==fOK)
	{
		byte* ret=new byte[0x03*0x10];
		for(int wfi=0;wfi<0x03;wfi++)
		{
			for(int wfj=0;wfj<0x10;wfj++)
			{
				ret[wfi*0x10+wfj]=DTrd[wfi][wfj];
			}
		}
		return ret;
	}
	else
	{
		pResult->hidResult=HIDResult_ReadError;
		return NULL;
	}
}
void CHIDWork::KeyData_UartRenew(int type, int mode,CProgressCtrl* pProgress,CInteractionData* pResult/*,CStatusBarCtrl* pStatusBar*/)
{
	// TODO: Add your control notification handler code here
	int i;//;j;k;
	int m=0;
	//第1种选择--
	byte ut_RN[0x30][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x19,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00--

		{0x01,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01},//01--发A0    --收50并比较
		{0x01,0xA1,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//02--发A1,03 --收03并比较

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01},//03--上电后等待接收红外数据
		{0x03,0x7A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//04--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//05--掉电后延时
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01},//06--上电后等待接收红外数据
		{0x03,0x7A,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xFF,0x01},//07--发红外8字节，然后收一组红外数据

		//	{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//08--掉电后延时
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//08--延时

		//	{0x01,0xA4,0x01,0x07,0xD0,0x76,0x55,0x07,0xD0,0x6D,0x60,0x00,0x00,0x0A,0x20,0x01},//09--握手配置
		{0x09,0xA4,0x01,0x07,0xD0,0x76,0x55,0x07,0xD0,0x6D,0x60,0x50,0x00,0x0A,0x06,0x01},//09--握手配置

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01},//0A--上电后等待接收红外数据

		{0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01},//0B--再收10-24数据
		//	{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x00},//0B--延时100ms


		{0x03,0x7A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//0C--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00},//0D--掉电后延时--分支--0x06
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x03,0x01},//0E--上电后等待接收红外数据0xC0

		{0x04,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x14,0x00},//0F--发红外8字节,下位机自动校验接收
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//10--掉电后延时
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x03,0x01},//11--上电后等待接收红外数据

		{0x03,0x7A,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xFF,0x01},//12--发红外8字节，然后收一组红外数据--
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//13--掉电后延时
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x03,0x01},//14--上电后等待接收红外数据

		{0x03,0x7A,0x0E,0x03,0x00,0x00,0x73,0xEF,0xB7,0x00,0x00,0x00,0x00,0x08,0xFF,0x01},//15--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//16--掉电后延时
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x03,0x01},//17--上电后等待接收红外数据


		{0x04,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x20,0x00},//18--发红外8字节,下位机自动校验接收
		{0x04,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x20,0x00},//19--发红外8字节,下位机自动校验接收
		{0x04,0x01,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x20,0x00},//1A--发红外8字节,下位机自动校验接收
		{0x04,0x01,0x03,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x20,0x00},//1B--发红外8字节,下位机自动校验接收
		{0x04,0x01,0x04,0xE6,0x88,0x8C,0x92,0x70,0x80,0xAA,0xF8,0x00,0x00,0x0A,0x20,0x00},//1C--发红外8字节,下位机自动校验接收//0x4D,0xDF,0x6F,0x75,0x1C,0x64,0xB4,0xED
		{0x03,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0xFF,0x01},//1D--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//1E--掉电后延时
		//
		{0x08,0x7A,0x10,0x2A,0xA5,0x13,0x73,0xEF,0xB7,0x00,0x00,0x00,0x00,0x08,0x40,0x00},//1F--发红外8字节，不收数据
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x00},//20--延时
		{0x08,0x7A,0x11,0x2A,0xA5,0x13,0x73,0xEF,0xB7,0x00,0x00,0xA0,0x00,0x08,0x40,0x00},//21--电源先掉电抖动，发红外8字节，不收数据
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00},//22--延时
		//	{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//23--掉电后延时
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00},//23--延时
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x00,0x03,0x01},//24--上电后等待接收红外数据
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x00},//25--延时--0xC8

		//		{0x04,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x0A,0x10,0x00},//26--发红外8字节,下位机自动校验接收
		{0x04,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x10,0x00},//26--发红外8字节,下位机自动校验接收

		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA8,0x00,0x00,0x00,0x00},//27--上电后等待接收红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//28--掉电后延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01},//29--上电后等待接收红外数据
		{0x03,0xBE,0xEE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xFF,0x01},//2A--发红外8字节，然后收一组红外数据

		{0x0C,0xEB,0xEB,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x0A,0x00,0x01},//2B--//数据转换
		{0x0D,0xEB,0xEB,0x00,0x9B,0x5F,0xEF,0x06,0xA6,0x2E,0x54,0x00,0x00,0x0A,0xFF,0x01},//2C--发红外8字节，然后收一组红外数据

		{0x0D,0xC1,0x13,0x12,0xBE,0x00,0x00,0x00,0x45,0x02,0xFE,0x00,0x00,0x0A,0xFF,0x01},//2D--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//2E--掉电后延时
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//2F--掉电后延时


	};
	const unsigned char IRS[0x04]={0xFF,0x00,0x00,0x00};
	const unsigned char RT[0x04]={0x01,0x03,0x03,0x03};
	//	const unsigned char RS[0x04][0x0A]={
	//		{0xA4,0x01,0x07,0xD0,0xD9,0xCF,0x07,0xD0,0x6D,0x60},//0--第1款--57
	//		{0xA4,0x01,0x07,0xD0,0x76,0x55,0x07,0xD0,0x6D,0x60},//1--第2款--03
	//		{0xA4,0x01,0x07,0xD0,0x75,0xAF,0x07,0xD0,0x6D,0x60},//2--第3款--06
	//		{0xA4,0x01,0x07,0xD0,0x73,0x00,0x07,0xD0,0x6D,0x60},//3--第4款--08
	//	};
	const unsigned char RSK[0x04][0x08]={
		{0xD9,0xCF,0xD9,0xCF,0xD9,0xCF,0xD9,0xCF},//0--第1款--57
		{0x76,0x55,0x76,0x53,0x00,0x00,0x00,0x00},//1--第2款--03
		{0x75,0xAC,0x75,0xAD,0x75,0xAE,0x75,0xAF},//2--第3款--06
		{0x73,0x00,0x73,0x01,0x73,0x02,0x73,0x03},//3--第4款--08
	};
	unsigned char Ssel=0x00;
	bool Fot=false;


	unsigned char P;
	//	unsigned char Rx;
	unsigned int cntR=0x00;
	unsigned int cntT=0x00;
	unsigned int cntQ=0x00;
	unsigned int cntD=0x00;//重试的时候掉电延时的计数

	unsigned int cntp=0x00;//接收33的计数

	//	unsigned char TMP[0x20][0x10];
	unsigned char tptx[0x10],tprx[0x10];
	//	unsigned char Lnt,JC;
	bool fBsel=false;//false is IR mode, true is PCB mode,

	if(0x00==type)
	{
		fBsel = false;//IR MODE

	}
	else
	{
		fBsel = true;//pcb
	}

	if(true==fBsel)
	{
		//mode=((CComboBox*)GetDlgItem(IDC_COMBO1))->GetCurSel();//后面通过选择框控制

		if(mode>0x03)//后续开发通过复选框控制模式
		{
			//MessageBox("选择未实现!!","Error",MB_OK);
			pResult->hidResult=HIDResult_RenewError;
			return;
		}//后续开发可删掉

		ut_RN[0x00][0x06]=IRS[mode];
		ut_RN[0x00][0x07]=0x00;
		ut_RN[0x02][0x02]=RT[mode];
	}
	else
	{
		ut_RN[0x00][0x06]=0x00;
		ut_RN[0x00][0x07]=0xFF;
		//	MessageBox("暂未实现!!","Error",MB_OK);
		//	return;
	}
	
	//--
	//ut_RN[0x00][0x06]=IRS[mode];
	//ut_RN[0x02][0x02]=RT[mode];
	//	for(i=0;i<0x0A;i++)
	//	{
	//		ut_RN[0x09][0x01+i]=RS[mode][i];
	//	}
	//--//--P 可用作进度条变量
	unsigned char ttR=0;//总体重试次数
	bool fAdd,fOK;//fRS,
	//	bool fSmode=false;
	bool fSHK=false;
	bool fSTP=false;//

	P=0;
	fOK=false;
	Fot=false;
	bool fSM=false;	
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x1e);
	pProgress->SetPos(0);
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x16;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		if(0x09==P)
		{
			ut_RN[0x09][0x05]=RSK[mode][Ssel++];
			ut_RN[0x09][0x06]=RSK[mode][Ssel++];
			Ssel=Ssel&0x07;
		}
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=ut_RN[P][i];
			tptx[i]=ut_RN[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{

		}
		for(i=0;i<0x10;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				if(false==fBsel)//IR MODE
				{
					fAdd=false;//无需递增
					P=0x29;
				}
				break;
				//------
			case 0x05://掉电后延时
			case 0x08://掉电后延时
				//	case 0x0D://掉电后延时
			case 0x10://掉电后延时
			case 0x13://掉电后延时
			case 0x16://掉电后延时

				break;
				//------
			case 0x0D://掉电后延时
				//if(true==Fot)
				//	{
				//		fAdd=false;//无需递增
				//		P=0x1F;
				//	}
				if(true==fSM)//Fot
				{
					//fAdd=false;//无需递增
					//P=0x1F;
				}
				else
				{
					fAdd=false;//无需递增
					P=0x1F;
				}
				break;
				//------
			case 0x28://掉电后延时
				fAdd=false;//无需递增
				cntD++;
				if(cntD>0x10)
				{
					//Fot=false;
					fSHK=false;
					//	fSmode=false;//首次握手模式
					cntR=0;//握手计数
					cntT=0;//状态字和为100，但不回数
					cntQ=0;//发7A10的次数的计数
					P=0x00;
				}
				break;
				//------
			case 0x01://发A0    --收50并比较
				if(0x50 != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x1E;
// 					DspRead="uart error0";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
			case 0x02://发A1,03 --收03并比较
				if(tptx[0x02] != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x1E;
// 					DspRead="uart error1";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://上电后等待接收红外数据
			case 0x06://上电后等待接收红外数据
				break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
			case 0x07://发红外8字节，然后收一组红外数据
				//	case 0x0C://发红外8字节，然后收一组红外数据
			case 0x15://发红外8字节，然后收一组红外数据

				break;
				//------
			case 0x0C://发红外8字节，然后收一组红外数据
				unsigned int tsm;
				tsm=tprx[0x05] + tprx[0x06];
				if(0x100==tsm)
				{
					//fAdd=false;//无需递增
					fSM=true;//sum is 100 flag
				}
				else
				{
					//fAdd=false;//无需递增
					//P=0x1F;
					fSM=false;
				}
				if((0x00==tprx[0x05])&&(0x00==tprx[0x06]))
				{
					fSM=true;
				}
				//	else
				//	{
				//		fSM=false;
				//	}
				break;
				//------
			case 0x12://发红外8字节，然后收一组红外数据
				if(0x03==tprx[0x03])
				{
					fAdd=false;//无需递增
					P=0x16;
				}
				else
				{
					//fAdd=false;//无需递增
					//P=0x16;
				}
				break;
				//------	

				//	break;
				//------	
				//	case 0x08://发红外8字节，然后收一组红外数据,TEST
				//			P=0x03;
				//			fAdd=false;//无需递增
				//			cntR++;
				//			if(cntR>0x100)
				//			{
				//				fSTP=true;//超限，跳出循环
				//				DspRead="uart TEST OK";//错误退出
				//				SetDlgItemText(IDC_EDIT11, DspRead);
				//			}
				//		break;
				//------
			case 0x09://握手配置
				if(tptx[0x0A] != tprx[0x01])
				{
					fAdd=false;//无需递增
					P=0x1E;
					//fSTP=true;//跳出循环
// 					DspRead="uart error2";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
			case 0x0A://收到红外数据
				fSHK=false;
				break;
				//----
			case 0x0B://延时100ms
				if(false==fSHK)
				{
					fAdd=false;//无需递增
					P=0x08;
					cntR++;
					if(cntR>0x200)
					{
						//fSTP=true;//超限，跳出循环
						//	P=0x1E;
						//	DspRead="uart error 6";//错误退出
						//	SetDlgItemText(IDC_EDIT11, DspRead);

						ttR++;
						if(ttR>0x05)
						{
							fAdd=false;//无需递增
							fSTP=true;//跳出循环
// 							DspRead="uart error 10";//错误退出
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						}
						else
						{
							fAdd=false;//无需递增
							P=0x28;
						}
					}
				}
				break;
				//----
			case 0x0F://发红外8字节,下位机自动校验接收
				break;
				//----			
			case 0x0E://上电后等待接收红外数据
			case 0x11://上电后等待接收红外数据
			case 0x14://上电后等待接收红外数据
			case 0x17://上电后等待接收红外数据
			case 0x24://
				fAdd=false;//无需递增
				P=0x1E;
				//fSTP=true;//跳出循环
// 				DspRead="uart IR ERROR0";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);

				break;
				//----
			case 0x18://发红外8字节,下位机自动校验接收
			case 0x19://发红外8字节,下位机自动校验接收
			case 0x1A://发红外8字节,下位机自动校验接收
			case 0x1B://发红外8字节,下位机自动校验接收
			case 0x1C://发红外8字节,下位机自动校验接收
				//空操作，P递增
// 				DspRead="uart renew data";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
			case 0x1D://发红外8字节，然后收一组红外数据
				//擦除结束
				fAdd=false;//无需递增
				fOK=true;
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="RF renew OK";
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x1E:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			case 0x1F:
			case 0x20:
			case 0x21:
			case 0x22:
			case 0x23:
			case 0x25:
			case 0x26:
				break;
				//------
				//case 0x24:
				break;
				//------
			case 0x27:
				fAdd=false;//无需递增
				P=0x12;
				break;

				//------
			case 0x29:
				if(0x33==tprx[1])
				{
					fAdd=false;//无需递增
					cntp++;
					if(cntp>0x80)
					{
						P=0x1E;
// 						DspRead="遥控异常";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				else
				{
				}
				break;
				//------
			case 0x2A:
				if((0xEE==tprx[1])&&(0xBE==tprx[2]))
				{
					for(i=0;i<0x08;i++)
					{
						ut_RN[0x2B][0x03+i]=tprx[3+i];
					}
				}
				else
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x1E;
// 					DspRead="uart IR error4";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x2B://数据转换
				for(i=0;i<0x08;i++)
				{
					ut_RN[0x2C][0x03+i]=tprx[3+i];
				}
				break;
				//------
			case 0x2C://发红外8字节，然后收一组红外数据
				if((0xEE==tprx[1])&&(0xEE==tprx[2]))
				{
				}
				else
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x1E;
// 					DspRead="uart IR error5";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x2D://发红外8字节，然后收一组红外数据
				//	for(i=0;i<0x10;i++)
				//	{
				//		DTrd[k][i]=tprx[i];
				//	}
				//	k++;
				//	if(k>=0x03)
				//	{
				//		fOK=true;
				//		fAdd=false;//无需递增
				//		//fSTP=true;//跳出循环
				//		P=0x1E;
				//	}
				if((0xC1==tprx[1])&&(0xDD==tprx[2]))
				{
					fOK=true;
					fAdd=false;//无需递增
					P=0x1E;
// 					DspRead="uart IR RENEW OK";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					fAdd=false;//无需递增
					P=0x1E;
// 					DspRead="uart IR error6";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);

				}
				break;
				//------


				//-----
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错
			case 0x05://掉电后延时
			case 0x08://掉电后延时
			case 0x0D://掉电后延时
			case 0x10://掉电后延时
			case 0x13://掉电后延时
			case 0x16://掉电后延时
			case 0x1E://掉电后延时
			case 0x28://掉电后延时
			case 0x25:
			case 0x2B://数据转换
				//break;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x01://发A0    --收50并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart cfg error0";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x02://发A1,03 --收03并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart cfg error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------	

				//------
			case 0x03://上电后等待接收红外数据
			case 0x06://上电后等待接收红外数据
				//此模式代表没有收到上电的遥控ID，可能是已经擦除过的。继续
			case 0x0E://上电后等待接收红外数据
			case 0x11://上电后等待接收红外数据
			case 0x14://上电后等待接收红外数据
			case 0x17://上电后等待接收红外数据
				break;
				//----
				//	case 0x03://上电后等待接收红外数据TEST
				//	case 0x06://上电后等待接收红外数据TEST
				//		if(cntR>0x01)
				//		{
				//			fSTP=true;//超限，跳出循环
				//			DspRead="uart TEST ERROR";//错误退出
				//			SetDlgItemText(IDC_EDIT11, DspRead);
				//		}
				//		break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
			case 0x07://发红外8字节，然后收一组红外数据
			case 0x0C://发红外8字节，然后收一组红外数据
				//	case 0x12://发红外8字节，然后收一组红外数据
			case 0x15://发红外8字节，然后收一组红外数据
			case 0x1D://发红外8字节，然后收一组红外数据
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart IR error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);	
				break;

			case 0x12://发红外8字节，然后收一组红外数据	
				//Fot=false;
				fSHK=false;
				//	fSmode=false;//首次握手模式
				cntR=0;
				cntT=0;
				cntQ=0;
				P=0x00;
				break;
				//------
			case 0x09://握手配置		
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart cfg error2";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x0A://收到红外数据
				fSHK=true;
				if(0x33 == tprx[0x01])
				{
					fSHK=false;
					//	fAdd=false;//无需递增
					//	fSTP=true;//跳出循环
					//	DspRead="uart SHAK OK";//错误退出
					//	SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if(true==fSHK)
				{
					fAdd=false;//无需递增
					P=0x0C;
					//	if(false==fSmode)
					//	{
					//		Ssel=0x00;//握手数据取数复位
					//		fSmode=true;
					//	}
				}
				break;
				//-----
			case 0x0B:
				if(false==fSHK)
				{
					fAdd=false;//无需递增
					P=0x08;
					cntR++;
					if(cntR>0x1000)
					{
						//fSTP=true;//超限，跳出循环
						P=0x1E;
// 						DspRead="uart error 6";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				break;
				//
				if(mode!=0x00)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x1E;
// 					DspRead="uart IR error2";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//----
			case 0x0F://发红外8字节，然后收一组红外数据	
				fAdd=false;//无需递增
				//DspRead="uart IR error3";//
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P=0x08;
				cntT++;
				if(cntT>=0x100)//0x20
				{
					//Fot=true;
					//		P=0x08;
					//fSTP=true;//超限，跳出循环
					//P=0x1E;
					//DspRead="uart error 7";//错误退出
					//SetDlgItemText(IDC_EDIT11, DspRead);
					//		cntT=0;
					ttR++;
					if(ttR>0x05)
					{
						fAdd=false;//无需递增
						fSTP=true;//跳出循环
// 						DspRead="uart error 7";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					else
					{
						fAdd=false;//无需递增
						P=0x28;
					}


				}
				break;
				//-----

				//----
			case 0x18://发红外8字节,下位机自动校验接收
			case 0x19://发红外8字节,下位机自动校验接收
			case 0x1A://发红外8字节,下位机自动校验接收
			case 0x1B://发红外8字节,下位机自动校验接收
			case 0x1C://发红外8字节,下位机自动校验接收
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart IR error3";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x1F:
			case 0x20:
			case 0x21:
			case 0x22:
			case 0x23:
				//	case 0x24:
				//	case 0x25:
			case 0x27:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="uart error 8";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x24:
				break;
				//------
			case 0x26:
				cntQ++;
				if(cntQ>0x100)//0x40
				{
					ttR++;//重试计数
					if(ttR>0x05)
					{
						fAdd=false;//无需递增
						fSTP=true;//跳出循环
// 						DspRead="uart error 9";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					else
					{
						fAdd=false;//无需递增
						P=0x28;
					}
				}
				else
				{
					fAdd=false;//无需递增
					P=0x08;
					//	cntT=0x00;
					//	Ssel=0x00;
					//	Fot=false;
				}
				break;
				//------
				//------
			case 0x29:
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="遥控器为空!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x2A:
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart IR error4-";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x2C:
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart IR error5-";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x2D:
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x1E;
// 				DspRead="uart IR error6-";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P==0x1F)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		//------------------
	}
	//------------------
	if(true==fOK)
	{
// 		DspRead="REASE OK";
// 		SetDlgItemText(IDC_EDIT11, DspRead);
		pResult->hidResult=HIDResult_OK;
	}
	else
	{
		pResult->hidResult=HIDResult_RenewError;
		//	DspRead="Write ERROR";
		//	SetDlgItemText(IDC_EDIT11, DspRead);
	}
}
void CHIDWork::KeyData_UartProgram(int type, int mode,CProgressCtrl* pProgress,CInteractionData* pResult,byte* pBuf/*,CStatusBarCtrl* pStatusBar*/)
{
	unsigned int i;
	int m=0;
	byte ut_PG[0x20][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x19,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00--

		{0x01,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01},//01--发A0    --收50并比较
		{0x01,0xA1,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//02--发A1,03 --收03并比较

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x01},//03--上电后等待接收红外数据
		{0x03,0x7A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//04--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//05--掉电后延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x01},//06--上电后等待接收红外数据
		{0x03,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x32,0x01},//07--发红外1字节，然后收一组红外数据--暂时不用
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//08--掉电后延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x01},//09--上电后等待接收红外数据

		{0x04,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x64,0x00},//0A--发红外8字节,下位机自动校验接收
		{0x0A,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x0A,0x64,0x00},//0B--发红外8字节,下位机自动校验接收--循环发数据17包,并记录数据
		{0x0B,0x35,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x0A,0x64,0x00},//0C--发红外8字节,下位机自动校验接收--总校验包

		{0x03,0x35,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0xFF,0x01},//0D--发红外8字节，然后收一组红外数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//0E--掉电后延时
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x01},//0F--上电后等待接收红外数据
		{0x03,0x7A,0x06,0x98,0x08,0x08,0x08,0x20,0x16,0x00,0x00,0x00,0x00,0x0A,0xFF,0x00},//10--发红外8字节，然后收一组红外数据--激活数据

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//11--掉电后延时

	};
	const unsigned char IRS[0x04]={0xFF,0x00,0x00,0x00};
	const unsigned char RT[0x04]={0x01,0x03,0x03,0x03};

	bool fBsel=false;//false is IR mode, true is PCB mode,
	unsigned char Ssel=0x00;
	bool fm35=false;//false is 35mode ,true is 37mode


	unsigned char P;
	//	unsigned int cntR=0x00;
	//	unsigned int cntT=0x00;
	//	unsigned int cntQ=0x00;
	//	unsigned int cntD=0x00;//重试的时候掉电延时的计数

	unsigned char tptx[0x10],tprx[0x10];

	if(0x00==type)
	{
		fBsel = false;//IR MODE
	}
	else
	{
		fBsel = true;
	}

	if(true==fBsel)
	{
		//mode=((CComboBox*)GetDlgItem(IDC_COMBO1))->GetCurSel();//后面通过选择框控制
		if(mode>0x03)//后续开发通过复选框控制模式,应该是PCB模式下再检查此值
		{
			//MessageBox("选择未实现!!","Error",MB_OK);
			pResult->hidResult=HIDResult_ReadError;
			return;
		}//后续开发可删掉
	}
	if(false==fBsel)
	{
		ut_PG[0x00][0x06]=0x00;
		ut_PG[0x00][0x07]=0xFF;
	}
	else//pcb
	{
		ut_PG[0x00][0x06]=IRS[mode];
		ut_PG[0x00][0x07]=0x00;

		ut_PG[0x02][0x02]=RT[mode];
	}
	//-----------------
	//---->补充的数据修正
	unsigned char SUM=0;
	for(i=0;i<9;i++)
	{
		SUM=SUM^pBuf[0x73+i];
	}
	pBuf[0x7C]=SUM;
	//--
	pBuf[0x80]=0x01;
	pBuf[0x81]=pBuf[0x8B];
	pBuf[0x82]=pBuf[0x8A];
	pBuf[0x83]=pBuf[0x89];
	pBuf[0x84]=pBuf[0x88];
	pBuf[0x85]=0xFF;
	pBuf[0x86]=0xFF;
	pBuf[0x87]=0x35;

	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x10);
	pProgress->SetPos(0);
	//--
	//--//--P 可用作进度条变量
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	unsigned char y=0x00;
	P=0x00;
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x16;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		if(0x0B==P)
		{
			for(i=0;i<0x08;i++)
			{
				ut_PG[0x0B][0x03+i]=pBuf[0x08*y+i];
			}
			ut_PG[0x0B][0x02]=y;
			y++;
		}
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=ut_PG[P][i];
			tptx[i]=ut_PG[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{

		}
		
		for(i=0;i<0x10;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				if(false==fBsel)//IR MODE
				{
					fAdd=false;//无需递增
					P=0x03;
				}
				break;
				//------
				//	case 0x05://掉电后延时
			case 0x08://掉电后延时
			case 0x0E://掉电后延时
				break;
				//------
			case 0x05://掉电后延时
				fAdd=false;//无需递增
				P=0x09;
				break;
				//------
			case 0x01://发A0    --收50并比较
				if(0x50 != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
// 					DspRead="uart error0";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
			case 0x02://发A1,03 --收03并比较
				if(tptx[0x02] != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
// 					DspRead="uart error1";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://上电后等待接收红外数据
			case 0x06://上电后等待接收红外数据
			case 0x09://上电后等待接收红外数据
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="遥控器非空!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
				unsigned int tsm;
				tsm=tprx[0x05] + tprx[0x06];
				if(0x100==tsm)
				{
					//fAdd=true;//递增
					if(0x21==tprx[0x05])
					{
						fm35=true;//37 mode
						ut_PG[0x0B][0x01]=0x37;
						ut_PG[0x0C][0x01]=0x37;
						ut_PG[0x0D][0x01]=0x37;
						pBuf[0x87]=0x37;
					}
					else
					{
						fm35=false;//35 mode
						ut_PG[0x0B][0x01]=0x35;
						ut_PG[0x0C][0x01]=0x35;
						ut_PG[0x0D][0x01]=0x35;
						pBuf[0x87]=0x35;
					}
				}
				else if((0x00==tprx[0x05])&&(0x00==tprx[0x06]))
				{
					fm35=false;//35 mode
					ut_PG[0x0B][0x01]=0x35;
					ut_PG[0x0C][0x01]=0x35;
					ut_PG[0x0D][0x01]=0x35;
					pBuf[0x87]=0x35;
				}
				else
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
// 					DspRead="遥控器状态字错误!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x07://发红外1字节，然后收一组红外数据

				break;
				//------
			case 0x0A://发红外8字节,下位机自动校验接收
				//	case 0x0B://发红外8字节,下位机自动校验接收
			case 0x0C://发红外8字节,下位机自动校验接收
				//空操作，P递增
// 				DspRead="uart write data";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x0B://发红外8字节,下位机自动校验接收
				fAdd=false;//无需递增
				if(y>0x10)
				{
					fAdd=true;//递增
				}
// 				DspRead="uart write data";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------	
			case 0x0D://发红外8字节，然后收一组红外数据

				break;
				//------
			case 0x0F://上电后等待接收红外数据
				fAdd=false;//无需递增
				P=0x11;
				fOK=true;
				break;
				//------
			case 0x10://上电后等待接收红外数据
				fOK=true;
				break;
				//------


				//------
			case 0x11:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错
			case 0x05://掉电后延时
			case 0x08://掉电后延时
			case 0x0E://掉电后延时
			case 0x11://掉电后延时

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x01://发A0    --收50并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="uart cfg error0";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x02://发A1,03 --收03并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="uart cfg error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x03://上电后等待接收红外数据
				//	case 0x06://上电后等待接收红外数据
				break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
			case 0x07://发红外1字节，然后收一组红外数据
			case 0x0D://发红外8字节，然后收一组红外数据

				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="uart IR error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x06://上电后等待接收红外数据
				fAdd=false;//无需递增
				P=0x09;
				break;
				//------
			case 0x09://上电后等待接收红外数据
				if(false==fm35)
				{//35 mode
					fAdd=false;//无需递增
					P=0x0A;
				}
				else
				{//37 mode
					fAdd=false;//无需递增
					P=0x0B;
				}
				break;
				//------
			case 0x0A://发红外8字节,下位机自动校验接收
			case 0x0B://发红外8字节,下位机自动校验接收
			case 0x0C://发红外8字节,下位机自动校验接收
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="uart IR error3";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x0F://上电后等待接收红外数据
				if(0x33 != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
					fOK=true;
// 					DspRead="接收IR数据超时!";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x10://上电后等待接收红外数据

				break;
				//------


				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x11)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		pProgress->SetPos(y);
		pProgress->UpdateWindow();
		//------------------
	}
	//------------------
	if(true==fOK)
	{
		pResult->hidResult=HIDResult_OK;
// 		DspRead="write OK";
// 		SetDlgItemText(IDC_EDIT11, DspRead);
	}
	else
	{
		pResult->hidResult=HIDResult_WriteError;
		//	DspRead="Write ERROR";
		//	SetDlgItemText(IDC_EDIT11, DspRead);
	}
	//------------------
}
byte* CHIDWork::KeyData_UartReadIR(int type, int mode,CProgressCtrl* pProgress,CInteractionData* pResult/*,CStatusBarCtrl* pStatusBar*/)
{
	VMProtectBegin("HIDWork_UartReadIR");
	// TODO: Add your control notification handler code here
	unsigned int i;

	int m=0;
	unsigned char DTrd[0x03][0x10];

	byte ut_RD[0x10][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x19,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00--

		{0x01,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01},//01--发A0    --收50并比较
		{0x01,0xA1,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01},//02--发A1,03 --收03并比较

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x01},//03--上电后等待接收红外数据
		{0x03,0x7A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//04--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},//05--掉电后延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01},//06--上电后等待接收红外数据
		{0x03,0x7A,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xFF,0x01},//07--发红外8字节，然后收一组红外数据
		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00},//08--掉电后延时


	};
	const unsigned char IRS[0x04]={0xFF,0x00,0x00,0x00};
	const unsigned char RT[0x04]={0x01,0x03,0x03,0x03};

	bool fBsel=false;//false is IR mode, true is PCB mode,
	unsigned char Ssel=0x00;
	bool fm35=false;//false is 35mode ,true is 37mode
	unsigned int tyct=0;

	unsigned char P;
	//	unsigned int cntR=0x00;
	//	unsigned int cntT=0x00;
	//	unsigned int cntQ=0x00;
	//	unsigned int cntD=0x00;//重试的时候掉电延时的计数

	unsigned char tptx[0x10],tprx[0x10];

	if(0x00==type)
	{
		fBsel = false;//IR MODE
	}
	else
	{
		fBsel = true;
	}
	if(true==fBsel)
	{
		//mode=((CComboBox*)GetDlgItem(IDC_COMBO1))->GetCurSel();//后面通过选择框控制
		if(mode>0x03)//后续开发通过复选框控制模式,应该是PCB模式下再检查此值
		{
			//MessageBox("选择未实现!!","Error",MB_OK);
			pResult->hidResult=HIDResult_ReadError;
			return NULL;
		}//后续开发可删掉
	}
	if(false==fBsel)
	{
		ut_RD[0x00][0x06]=0x00;
		ut_RD[0x00][0x07]=0xFF;
	}
	else//pcb
	{
		ut_RD[0x00][0x06]=IRS[mode];
		ut_RD[0x00][0x07]=0x00;

		ut_RD[0x02][0x02]=RT[mode];
	}
	//--//--P 可用作进度条变量
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	unsigned char y=0x00;
	P=0x00;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,8);
	pProgress->SetPos(0);
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x16;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=ut_RD[P][i];
			tptx[i]=ut_RD[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{

		}
		//--
		for(i=0;i<0x10;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				if(false==fBsel)//IR MODE
				{
					fAdd=false;//无需递增
					P=0x03;
				}
				break;
				//------
			case 0x05://掉电后延时
				//fAdd=false;//无需递增
				//P=0x09;
				break;
				//------
			case 0x01://发A0    --收50并比较
				if(0x50 != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x08;
					pResult->hidResult=HIDResult_ReadError;
// 					DspRead="uart error0";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
			case 0x02://发A1,03 --收03并比较
				if(tptx[0x02] != tprx[0x01])
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x08;
					pResult->hidResult=HIDResult_ReadError;
// 					DspRead="uart error1";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://上电后等待接收红外数据
				if(0x33 != tprx[0x01])
				{
					for(i=0;i<0x10;i++)
					{
						DTrd[0][i]=tprx[i];
					}
				}
				else
				{
					fAdd=false;//无需递增
					tyct++;
					if(tyct>0x80)
					{
						//fAdd=false;//无需递增
						P=0x08;
						pResult->hidResult=HIDResult_ReadError;
						//DspRead="uart IR error3";//错误退出
					}

				}
				break;
				//------
			case 0x06://上电后等待接收红外数据
				//if(0x33 == tprx[0x01])

				break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
				for(i=0;i<0x10;i++)
				{
					DTrd[1][i]=tprx[i];
				}
				break;
				//------
			case 0x07://发红外8字节，然后收一组红外数据
				for(i=0;i<0x10;i++)
				{
					DTrd[2][i]=tprx[i];
				}
				fOK=true;
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x08;
				break;
				//------
			case 0x08:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错
			case 0x05://掉电后延时
			case 0x08://掉电后延时

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x01://发A0    --收50并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x08;
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="uart cfg error0";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x02://发A1,03 --收03并比较
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x08;
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="uart cfg error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x03://上电后等待接收红外数据
			case 0x06://上电后等待接收红外数据
				//	if(0x33 == tprx[0x01])
				//	{

				tyct++;
				if(tyct>0x02)//0x80
				{
					//fAdd=false;//无需递增
					//P=0x08;
					//DspRead="uart IR error4";//错误退出
				}
				else
				{
					fAdd=false;//无需递增
				}
				//	}
				//	else
				//	{
				//		fAdd=false;//无需递增
				//		P=0x08;
				//		DspRead="遥控数据为空!";//错误退出
				//		SetDlgItemText(IDC_EDIT11, DspRead);
				//	}
				break;
				//------
			case 0x04://发红外8字节，然后收一组红外数据
			case 0x07://发红外1字节，然后收一组红外数据
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x08;
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="uart IR error1";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				pResult->hidResult=HIDResult_ReadError;
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x08)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		//------------------
	}	
	//------------------
	if(true==fOK)
	{
		byte* ret=new byte[0x03*0x10];
		for(int wfi=0;wfi<0x03;wfi++)
		{
			for(int wfj=0;wfj<0x10;wfj++)
			{
				ret[wfi*0x10+wfj]=DTrd[wfi][wfj];
			}
		}
		return ret;
	}
	else
	{
		return NULL;
		//	DspRead="Write ERROR";
		//	SetDlgItemText(IDC_EDIT11, DspRead);
	}
	//------------------
	VMProtectEnd();
}
CString CHIDWork::GetCANInfoStr( byte* pBuf )
{
	VMProtectBegin("HIDWork1");
	CString str,strx,strxx;
	CString strTemp,strTemp1,strInfo;
	char ljh[11];
	for (int i = 0; i < 10; i++)
		ljh[i] = pBuf[0x4 + i];
	ljh[10] = 0;
	str=ljh;
	strInfo=_T("");
	strTemp.LoadString(NULL,IDS_MBLJH,CCarKey3App::LANGID);
	strTemp=_T("EZS ")+strTemp;
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";


	strTemp.LoadString(NULL,IDS_HardStatus,CCarKey3App::LANGID);
	str=CCommFunc::byteToHexStr(pBuf, 0, 2, _T(" "));
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";


	strTemp.LoadString(NULL,IDS_SoftStatus,CCarKey3App::LANGID);
	str=CCommFunc::byteToHexStr(pBuf, 2, 2, _T(" "));
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";

	strInfo+=_T("-----------------------------");
	strInfo+="\r\n";

	strTemp.LoadString(NULL,IDS_OperationalStatus,CCarKey3App::LANGID);
	strInfo+=strTemp+_T(":");
	strInfo+="\r\n";

	CString str1, str2, str3, str4;
	strTemp.LoadString(NULL,IDS_Initialised,CCarKey3App::LANGID);
	if (CCommFunc::GetBit(pBuf[0x13], 0))
	{		
		strTemp1.LoadString(NULL,IDS_Yes,CCarKey3App::LANGID);
		str1 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(NULL,IDS_No,CCarKey3App::LANGID);
		str1 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(NULL,IDS_TPRemoved,CCarKey3App::LANGID);
	if (CCommFunc::GetBit(pBuf[0x13], 1))
	{		
		strTemp1.LoadString(NULL,IDS_Yes,CCarKey3App::LANGID);
		str2 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(NULL,IDS_No,CCarKey3App::LANGID);
		str2 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(NULL,IDS_Personalised,CCarKey3App::LANGID);
	if (CCommFunc::GetBit(pBuf[0x13], 2))
	{		
		strTemp1.LoadString(NULL,IDS_Yes,CCarKey3App::LANGID);
		str3 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(NULL,IDS_No,CCarKey3App::LANGID);
		str3 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(NULL,IDS_Activated,CCarKey3App::LANGID);
	if (CCommFunc::GetBit(pBuf[0x13], 3))
	{		
		strTemp1.LoadString(NULL,IDS_Yes,CCarKey3App::LANGID);
		str4 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(NULL,IDS_No,CCarKey3App::LANGID);
		str4 = strTemp+_T(":")+strTemp1;
	}	
	strInfo+=str1;
	strInfo+="\r\n";
	strInfo+=str2;
	strInfo+="\r\n";
	strInfo+=str3;
	strInfo+="\r\n";
	strInfo+=str4;
	strInfo+="\r\n";

	strInfo+=_T("-----------------------------");
	strInfo+="\r\n";

	strTemp.LoadString(NULL,IDS_StateOfKeys,CCarKey3App::LANGID);
	strInfo+=strTemp+_T(":");
	strInfo+="\r\n";

	for(int i=7;i>=0;i--)
	{
		strTemp.LoadString(NULL,IDS_Key,CCarKey3App::LANGID);
		if (CCommFunc::GetBit(pBuf[0x12], i))
		{		
			strx.LoadString(NULL,IDS_Locked,CCarKey3App::LANGID);
			strxx.Format(_T("%s %d : %s"),strTemp,7-i,strx);			
		}
		else
		{
			strx.LoadString(NULL,IDS_UnLock,CCarKey3App::LANGID);
			strxx.Format(_T("%s %d : %s"),strTemp,7-i,strx);	
		}
		strInfo+=strxx;
		strInfo+="\r\n";
	}
	strInfo+=_T("=============================");
	return strInfo;
	VMProtectEnd();
}
byte* CHIDWork::CANReadInfoData( int mode,CProgressCtrl* pProgress,CInteractionData* pResult)
{
	VMProtectBegin("HIDWork2");
	//第1款
	const byte info_a[0x0B][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x1A,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款
	const byte info_b[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte info_c[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款
	const byte info_d[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x1A,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte info_e[0x0D][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte info_g[0x0D][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte info_h[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//转存规则
	const byte info_T[0x09][0x16]={
		{0x0A,0x0B,0x0C,0x0D,0x0F,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x19,0x1A,0x26,0x27,0x29,0x2A,0x2B,0x2C,0x2D,0x2E},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x31},
		{0x0A,0x0B,0x0C,0x0D,0x0F,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x19,0x1A,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36},
		{0x0C,0x0D,0x14,0x15,0x1D,0x1E,0x1F,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x31},
		{0x0C,0x0D,0x14,0x15,0x1D,0x1E,0x1F,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x0C,0x0D,0x1C,0x1D,0x2D,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x51},
		{0x0C,0x0D,0x1C,0x1D,0x2D,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x51},
	};
	byte rdINFO[0x09]={0x0B,0x0C,0x0C,0x0C,0x0D,0x0C,0x0D,0x0C,0x0C};
	int k=rdINFO[mode];
	int i,j;
	byte TMP[0x20][0x10];
	switch(mode)
	{
		//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_a[j][i];
			}
		}
		break;
		//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_b[j][i];
			}
		}
		break;
		//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_c[j][i];
			}
		}
		break;
		//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_d[j][i];
			}
		}
		break;
		//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_e[j][i];
			}
		}
		break;
		//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_g[j][i];
			}
		}
		break;
		//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_h[j][i];
			}
		}
		break;
		//------

		//------
	default:
		pResult->hidResult= HIDResult_RxError;
		//MessageBox("未实现!!","Error",MB_OK);
		return NULL;
	}
	// 	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	// 	pProgress->SetPos(0);
	// 	pProgress->UpdateWindow();
	int pBufIndex=0;
	int cntR=0;
	int m=0;
	CInteractionData tx;
	CInteractionData rx;
	byte Rx;
	byte tmpRX[0x80];
	int P;
	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for (P=0;P<k;)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];;
		}
		Rx=tx.buff[0x1F];
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			//rx.hidResult= HIDResult_OK;
			cntR=0;
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
			}
			P++;
		}
		else
		{
			//rx.hidResult= HIDResult_CANErr;
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{//非01包数据时的情况
				if((Rx>0x00)&&(Rx<0x80))
				{
					//ShowLog(rx.GetHIDResult());//非握手包数据返回错误
					//pResult->hidResult=HIDResult_CANErr;
					pResult->hidResult=HIDResult_ReadEZSError6;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						//ShowLog(rx.GetHIDResult());//重复多次握手后仍错误
						//pResult->hidResult=HIDResult_CANErr;
						pResult->hidResult=HIDResult_ReadEZSError6;
						return NULL;
					}
				}
			}
		}
		//------------------
		if((Rx>0x00)&&(Rx<0x80))
		{
			for(i=0;i<0x08*Rx;i++)
			{
				tmpRX[m+i]=rx.buff[i+0x10];
			}
			m+=(0x08*Rx);
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
	}
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x80+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x80);
	outBuf[0x80]=0;

	for(int i=0;i<0x16;i++)//0x80
	{
		j=info_T[mode][i];
		outBuf[i]=tmpRX[j];
	}
	return outBuf;
	VMProtectEnd();
}
byte* CHIDWork::IRReadData( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar)
{
	VMProtectBegin("HIDWork3");
	// TODO: Add your control notification handler code here
	unsigned int i,j,k;
	char tmp_cmd;
	//	char BufPassWord[0x18];
	char Data[0x10*0x30];

	unsigned char Hsel[0x04][0x08];
	unsigned char Hnxt[0x03][0x08];
	unsigned char Htmp[0x08];
	//char DispSSD[0x0C];

	unsigned int m;
	unsigned char n,x,y;
	bool fSEL=false;
	bool fSam=false;
	bool fChk=false;
	unsigned char Scnt;


	bool FLGsel=false;
	bool Fspec=false;
	const byte fix[0x08]={0xC2,0xE9,0x01,0xF0,0xED,0xBA,0x7C,0x5C};
	switch(mode)
	{
		//------
	case 0x00:
	case 0x01:
	case 0x03:
		FLGsel=false;
		Fspec=false;
		break;
		//------
	case 0x02:
	case 0x05:
	case 0x07:
		FLGsel=true;
		Fspec=false;
		break;
		//------
	case 0x04:
	case 0x06:
		FLGsel=false;
		Fspec=true;
		break;
		//------

		//------
	default:

		return NULL;
	}

	pProgress->SetRange(0,100);   //设置进度条的范围为0-1000	
	pProgress->SetPos(100);
	pProgress->UpdateWindow();
	CString strTemp;
	strTemp.LoadString(NULL,IDS_WaitInsertKey);
	pStatusBar->SetText(strTemp, 0, 0);
	//m_pProgress=pProgress;
	bool bNeedInster=true;
	// 	pProgress->SetRange(0,0x30);   //设置进度条的范围为0-1000	
	// 	pProgress->SetPos(0);
	// 	pProgress->UpdateWindow();
	bool bFail=false;
	for(i=0;i<0x10*0x30;i++)//0x80
	{
		Data[i]=0x00;
	}
	bool fShake=false;
	bool fSave=false;
	unsigned char MaxER=0x00;
	CInteractionData tx;
	CInteractionData rx;
	for(j=0,n=0;j<0x30;)//j++
	{
		tx.Init();
		tx.buff[0] = 0x0d;
		tx.buff[1] = 0x55;	//主机-->设备 

		tx.buff[0x0A] = 0x02;//cnt
		tx.buff[0x0B] = 0x6F;            

		tx.buff[0x0C] = (byte)j; 

		tmp_cmd=tx.buff[0x0C];

		rx = DeviceInteraction(tx);
		fSave=false;
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00 && rx.buff[0x0b]==0x70)
		{
			if(bNeedInster)
			{
				bNeedInster=false;
				m_pProgress=NULL;
				pProgress->SetRange(0,0x30);   //设置进度条的范围为0-1000	
				pProgress->SetPos(++n);
				pProgress->UpdateWindow();
			}
			if(fShake==false)
			{
				strTemp.LoadString(NULL,IDS_StartReadData);
				pStatusBar->SetText(strTemp, 0, 0);
			}
			fSave=true;
			fShake=true;
			MaxER=0x00;
			//j++;
			pProgress->SetPos(++n);
			pProgress->UpdateWindow();//i加1，同时设置新的进度位置
		}		
		else  if((rx.buff[0x01]==0x02)||(rx.buff[0x01]==0x01))
		{
			if(false==fShake)
			{
				MaxER++;
				pProgress->SetPos(100-MaxER);
				pProgress->UpdateWindow();
				if(MaxER>100)
				{
					//DspRead="Read Error2";//长时间没有插入车载端，超时
					//SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult=HIDResult_InsertKeyTimeOut;
					return NULL;
				}
			}
			else
			{
				MaxER++;
				if(MaxER>30)
				{
					//握手后连续30次，收到无效数据或没收到数据
					//pResult->hidResult=HIDResult_ReadEZSError4;
					//return NULL;
					fSave=true;
					for(k=0;k<8;k++)
					{
						rx.buff[0x10+k]=0x00;
					}
					//if(j<0x30)
					//{
					//	j++;
					//}
				}
			}
		}
		else  if(rx.buff[0x0B]!=0x70)
		{
			pResult->hidResult=HIDResult_ReadEZSError3;
			return NULL;
		}
		//else  if(BufInput[0x0C]!=tmp_cmd)//j
		//{
		//	DspRead="Read Error4";
		//	SetDlgItemText(IDC_EDIT11, DspRead);
		//	return;
		//}
		else
		{
			pResult->hidResult=HIDResult_ReadEZSError5;
			return NULL;
		}
		if(true==fSave)
		{
			for(k=0;k<8;k++)
			{
				Data[0x10*j+k]=rx.buff[0x10+k];
				//RDData[0x10*j+k]=rx.buff[0x10+k];
			}
			if(j<0x30)
			{
				j++;
			}
		}
	}
	//pResult->hidResult=HIDResult_OK;
	//------------------
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x400+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x400);
	outBuf[0x400]=0;

	//for(i=0;i<m;i++)//0x80
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//-----------------
	if(true==Fspec)
	{
		for(i=0;i<0x80;i++)
		{
			Data[0x270+i]=Data[0x20+i];
		}
		for(i=0;i<0x08;i++)
		{
			Data[0x260+i]=Data[0x100+i];
		}
	}
	//-----------------
	if(true==FLGsel)
	{
		for(k=0;k<0x08;k++)
		{
			m=0x0020;
			for(i=0;i<0x04;i++)
			{
				for(j=0;j<0x08;j++)
				{
					Hsel[i][j]=Data[m+k*0x10+j];
				}
				m=m+0x80;
			}
			//-----
			x=0x00;
			fSEL=false;
			while(false==fSEL)
			{
				CPassCalc cpCalc;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=Hsel[x][i];
				}
				cpCalc.sub_HashOnce();
				j=0x00;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=cpCalc.HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				cpCalc.sub_HashOnce();
				j=0x01;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=cpCalc.HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				cpCalc.sub_HashOnce();
				j=0x02;
				for(i=0;i<8;i++)
				{
					//HashIn[i]=HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				//--
				Scnt=0x00;
				for(j=0;j<0x04;)//j++
				{
					if(j==x)
					{
						j++;
					}
					for(i=0;i<0x08;i++)
					{
						Htmp[i]=Hsel[j][i];
					}
					//--
					fChk=false;
					n=0x00;
					while(false==fChk)
					{
						fSam=true;
						for(i=0;i<0x08;i++)
						{
							if(Htmp[i]!=Hnxt[n][i])
							{
								fSam=false;
							}
						}
						if(true==fSam)
						{
							fChk=true;
							Scnt++;
						}
						else
						{
							n++;
							if(n==0x03)
							{
								fChk=true;
							}
						}
					}
					//--
					j++;
					if(j==x)
					{
						j++;
					}
					//--
				}
				if(0x03==Scnt)
				{
					fSEL=true;
					y=x;
				}
				else
				{
					x++;
					if(x==0x04)
					{
						fSEL=true;
						y=0x00;
					}
				}
			}
			//--
			for(i=0;i<0x08;i++)
			{
				Data[0x270+k*0x10+i]=Hsel[y][i];
			}
		}
		//-------
		fSam=true;
		for(i=0;i<0x08;i++)
		{
			if(Data[0x260+i]!=0x00)
			{
				fSam=false;
			}
		}
		if(true==fSam)
		{
			for(i=0;i<0x08;i++)
			{
				Data[0x260+i]=fix[i];
			}
		}
		//-------
	}
	//-----------------
	for(i=0;i<0x10*0x30;i++)//0x80
	{
		outBuf[i]=Data[i];
	}
	strTemp.LoadString(NULL,IDS_FinishReadData);
	pStatusBar->SetText(strTemp, 0, 0);
	//-----------------
	return outBuf;
	VMProtectEnd();
}

byte* CHIDWork::CANReadEEPROM( int mode,CProgressCtrl* pProgress,CInteractionData* pResult )
{
	//VMProtectBegin("HIDWork4");
	int i,j;

	byte tmpRX[0x800];
	int m=0;
	//第1款--无错误动态字发生
	const byte CANee_A[0x0F][0x10]={
		//{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		//{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x05,0x6F,0x26,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANee_B[0x0B][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANee_C[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANee_D[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x21,0x05,0x6F,0x2F,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANee_E[0x0C][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANee_G[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANee_H[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	unsigned char P;//每次所需发送组索引
	unsigned char Rx;//每帧的最后一个字节，用于功能判断
	unsigned char cntR=0x00;//错误计数

	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;
	unsigned char k;

	byte rdEEDT[0x09][0x06]={
		{0x0F,0x08,0x0A,0x1A,0x00,0x00},//1--无错误
		{0x0B,0x05,0x07,0x1C,0x00,0x00},//2--无错误
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//3--
		{0x0C,0x05,0x07,0x1A,0x00,0x00},//4--无错误
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//5--
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//6--
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//7
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//8
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//9
	};
	byte rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

	k = rdEEDT[mode][0x00];//数据中帧总数
	LPstart = rdEEDT[mode][0x01];//循环起始帧
	LPend = rdEEDT[mode][0x02];//循环结束帧
	Z = rdEEDT[mode][0x03];//需要动态调整的命令号所在位置
	JC = rdEEDT[mode][0x05];//需要核查的帧编号

	bool fCK=false;//是否需要核查
	bool fRS=false;//核查结果是否正确
	bool fSAV=false;//此帧接收数据是否需要存储
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	} 
	//--//--LPcnt 可用作进度条变量
	//*/
	LPcnt=0x00;
	Ccnt=0x00;
	pProgress->SetRange(0,47);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	CInteractionData tx;
	CInteractionData rx;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];;
		}		
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = LPcnt;
		}
		rdCK[0x07] = LPcnt;//检查备用

		rx = DeviceInteraction(tx);

		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			//
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
			}
			//
			if((true==fCK)&&(JC==P))//需要检查而且行表一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x2F))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x2F)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					//请确认EIS类型选择是否正确，及ODB连接是否正确
					pResult->hidResult=HIDResult_ReadEZSError6;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						//请确认EIS类型选择是否正确，及ODB连接是否正确
						pResult->hidResult=HIDResult_ReadEZSError6;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//------------------
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//------------------
		}
		pProgress->SetPos(LPcnt);
		pProgress->UpdateWindow();
		
	}
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x800+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x800);//0X00
	outBuf[0x800]=0;

	const byte TS[0x09][0x0a]={
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//1--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//2--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//3--
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//4--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//5--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//6--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//7--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];

	for(i=0;i<0x30;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//--
	i=0;
	AdL=TS[mode][4];
	AdC=TS[mode][5];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][6];
	AdC=TS[mode][7];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][8];
	AdC=TS[mode][9];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	return outBuf;
	//VMProtectEnd();
}


void CHIDWork::CANWriteEZS( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,CEZSData* pEZSData)
{
	VMProtectBegin("HIDWork5");
	int i,j,k;
	bool Shk=false;
	int OVchk=0;
	int m=0;
	//char *pBuf;
	//DWORD dwFileLen;
	//
	//第1款
	const byte CANwr_A[0x16][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x0B,0x31,0x22,0x0A,0x7C,0xFE,0xD6,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x71},//0x71,替换为文件ID数据，然后高字节置零
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x00,0x01},//0A
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//0B
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x12,0x00},//0C
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x1E,0x71},//
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款
	const byte CANwr_B[0x11][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x03,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//09-
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x03,0x22,0x0B,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x30,0x71},
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	
	};
	//第3款,第6款
	const byte CANwr_C[0x0E][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x71},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//
	//第4款
	const byte CANwr_D[0x10][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0B,0x31,0x22,0x0A,0x7C,0xFE,0xD6,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x5C,0x68,0xFF,0x98,0x9C,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x30,0x71},//0B
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

	//第5款
	const byte CANwr_E[0x11][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x02,0x00},
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x28,0x71},//0C
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

	//第7款//第8款//第9款
	const byte CANwr_G[0x11][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x02,0x00},
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x28,0x71},//0C
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	byte CANwr_CK[0x03][0x10]={
		{0x07,0x03,0x7F,0x31,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x08,0x55,0x10,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//unused
		{0x07,0x03,0x7F,0x31,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//unused
	};
	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,LPdt,LPcnt;
	unsigned char SHstart,SHend,SHck,SHcnt;
	unsigned char SUstart,SUend,SUcnt;
	unsigned char total;

	unsigned char wrEEDT[0x09][0x09]={
		{0x16,0x09,0x0B,0x0A,0x0C,0x0D,0x0E,0x0F,0x0F},//1----

		{0x11,0x09,0x0B,0x0A,0xFF,0xFF,0x0D,0x0D,0x0D},//2----

		{0x0E,0x08,0x09,0x08,0xFF,0xFF,0x0A,0x0A,0x0A},//3----

		{0x10,0x08,0x0A,0x09,0xFF,0xFF,0x0C,0x0C,0x0C},//4----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//5----

		{0x0E,0x08,0x09,0x08,0xFF,0xFF,0x0A,0x0A,0x0A},//6----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//7----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//8
		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//9
	};

	total = wrEEDT[mode][0x00];//帧总数量
	SHstart = wrEEDT[mode][0x01];//循环握手的开始行标
	SHend = wrEEDT[mode][0x02];  //循环握手的结尾行标
	SHck =  wrEEDT[mode][0x03];  //循环握手的核对行标
	SUstart = wrEEDT[mode][0x04];//再确认握手的开始行标
	SUend = wrEEDT[mode][0x05];  //再确认握手的结尾行标


	SHcnt = 0x00; //握手计数
	SUcnt=0x00; //在确认的计数
	bool fShake=false;
	bool fSure=false;

	LPstart = wrEEDT[mode][0x06];
	LPend = wrEEDT[mode][0x07];
	LPdt = wrEEDT[mode][0x08];
	LPcnt = 0x00;
	bool fDT=false;

	bool fRS=false;//握手数据比较标识
	bool fAdd=false;

	bool fDone=false;

	unsigned char Wake=0x00;//唤醒包的重复次数
	
	switch(mode)
	{
	case 0x00:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_A[j][i];
			}
		}
		break;
	case 0x01:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_B[j][i];
			}
		}
		break;
	case 0x02:
	case 0x05:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_C[j][i];
			}
		}
		break;
	case 0x03:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_E[j][i];
			}
		}
		break;
	case 0x06:
	case 0x07:
	case 0x08:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_G[j][i];
			}
		}
		break;
	default:
		pResult->hidResult=HIDResult_CANErr;
		return;
	}
	//-----------------------------------------
	
	char DTwr[0x0C*0X08];
	for(i=0,j=0;i<0x08*0x08;i++)
	{
		DTwr[i]=pEZSData->AllFile[(0x270+(i/0x08)*0x10)+j];
		j++;
		j=j%0x08;
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x40+i]=pEZSData->AllFile[0x10+i];
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x48+i]=pEZSData->PSW[i];//此处判断文件是否已载入过，即可使用，如果未载入要提示打开BIN文件
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x50+i]=pEZSData->AllFile[0x220+i];
	}
	for(i=0;i<4;i++)
	{
		DTwr[0x58+i]=pEZSData->AllFile[0x00+i];
	}
	DTwr[0x58+0x04]=0x00;
	DTwr[0x58+0x05]=0x00;
	DTwr[0x58+0x06]=0x00;
	DTwr[0x58+0x07]=0x1c;
	int P;
	unsigned char Rx;

	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,total);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	//*///--P 可用作进度条变量,以下有地方需要留意，请下翻
	k=0;
	bool bStartWR=false;
	for(P=0;P<total;)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x70==(Rx&0xF0))
		{
			Rx=Rx&0x0F;
			tx.buff[0x1F]=Rx;
			tx.buff[0x13]=DTwr[0x58];
			tx.buff[0x14]=DTwr[0x59];
			tx.buff[0x15]=DTwr[0x5A];
			tx.buff[0x16]=DTwr[0x5B];
		}
		if(P==LPstart && bStartWR==false)
		{
			CString strTemp;
			strTemp.LoadString(NULL,IDS_CANWritting);
			pStatusBar->SetText(strTemp,0,0);
			pProgress->SetRange(0,0x0b);   //设置进度条的范围为0-1000	
			pProgress->SetPos(0);
			pProgress->UpdateWindow();
			bStartWR=true;
		}
		if(P==LPdt)
		{			
			for(i=0;i<0x08;i++)
			{
				tx.buff[i+0x13]=DTwr[0x08*k+i];//DATAwr[k][i];
			}
			tx.buff[0x12]=k;
			k++;
		}
		rx = DeviceInteraction(tx);
		fAdd=true;//默认是要递增取数位置的
		fDone=false;//执行过标识true代表已经执行过，不再进入执行
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			if(0x01==P)
				{
					P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
					fAdd=false;//无需递增
					fDone=true;
				}
				//---<
				//--public part
				if((P==LPend)&&(false==fDT)&&(false==fDone))
				{
					fDone=true;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
					//CCarKey3App::WaitMS(1);
					if(LPcnt<0x0C)
					{
						P=LPstart;
						fAdd=false;//无需递增
					}
					else
					{
						fDT=true;
					}
				}
				//--
				//--第1款车载端
				if(0x00==mode)
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						pProgress->SetPos(0x80-SHcnt);
						pProgress->UpdateWindow();
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
					if((SHck==P)&&(false==fDone))//检查
					{
						fRS=true;
						for(i=0;i<CANwr_CK[0][0];i++)
						{
							if(CANwr_CK[0][i+0x01]!=rx.buff[i+0x10])
							{
								fRS=false;
							}
						}
						if(true==fRS)
						{
							P=SUstart;
							fShake=true;
							fAdd=false;//无需递增
						}
						fDone=true;
					}
				}
				//--第2,4款车载端
				if((0x01==mode)||(0x03==mode))
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						pProgress->SetPos(0x80-SHcnt);
						pProgress->UpdateWindow();
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;						
					}
					//
					if((SHck==P)&&(false==fDone))//检查
					{
						//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						CString strTemp;
						strTemp.LoadString(NULL,IDS_WaitInsertKey);
						pStatusBar->SetText(strTemp,0,0);
						pProgress->SetRange(0,0x80);   //设置进度条的范围为0-1000	
						pProgress->SetPos(0x80);
						pProgress->UpdateWindow();
						fDone=true;
					}
				}
				//--第3,6款车载端
				if((0x02==mode)||(0x05==mode))
				{
					if((SHck==P)&&(false==fDone))//检查
					{
						P+=2;//2
						fShake=true;
						fAdd=false;//无需递增
						fDone=true;
					}
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						pProgress->SetPos(0x80-SHcnt);
						pProgress->UpdateWindow();
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
				}				
				//--第5,7,8,9款车载端
				if((0x04==mode)||(0x06==mode)||(0x07==mode)||(0x08==mode))
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						pProgress->SetPos(0x80-SHcnt);
						pProgress->UpdateWindow();
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
					if((SHck==P)&&(false==fDone))//需要检查而且行标一致
					{
						fRS=true;
						for(i=0;i<CANwr_CK[0][0];i++)
						{
							if(CANwr_CK[0][i+0x01]!=rx.buff[i+0x10])
							{
								fRS=false;
								//fAdd=true;//需递增
							}
						}
						if(true==fRS)
						{
							P+=3;//2
							fShake=true;
							fAdd=false;//无需递增
						}
						else
						{
							//--提示插入读设备
// 							DspRead="waiting insert device KEY";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							CString strTemp;
							strTemp.LoadString(NULL,IDS_WaitInsertKey);
							pStatusBar->SetText(strTemp,0,0);
							pProgress->SetRange(0,0x80);   //设置进度条的范围为0-1000	
							pProgress->SetPos(0x80);
							pProgress->UpdateWindow();
						}
						fDone=true;
					}
				}
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				//P++;//意为数据包加1，就是到了83.3K的数据包指向。
				//fAdd=true;//需递增
				fDone=true;
			}
			if((0x03==P)&&(false==fDone))
			{
// 					DspRead="Error 波特率";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox("Read Error","Read",MB_OK);
				//fDone=true;
				pResult->hidResult=HIDResult_CANErr;
				return;
			}
			//---第1款车载端
			if(0x00==mode)
			{
				//if(0x01==P)
				//{
					//fAdd=true;//需递增
				//}
				if((SHstart==P)&&(false==fDone))//((SHstart==P)&&(0x03==BufInput[1]))
				{
					//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					//P++;
					CString strTemp;
					strTemp.LoadString(NULL,IDS_WaitInsertKey);
					pStatusBar->SetText(strTemp,0,0);
					pProgress->SetRange(0,0x80);   //设置进度条的范围为0-1000	
					pProgress->SetPos(0x80);
					pProgress->UpdateWindow();
					fDone=true;
				}
				if((SUend==P)&&(false==fDone))
				{					
					fDone=true;
					SUcnt++;					
					if(SUcnt>0x40)
					{
// 							DspRead="Error shake 2";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult=HIDResult_CANErr;
						return;
					}
					else
					{
						P=SUstart;
						fAdd=false;//无需递增
					}
				}
			}
			//---第2,4款车载端
			if((0x01==mode)||(0x03==mode))
			{
				if((SHck==P)&&(false==fDone))//需要检查而且行标一致
				{
					fDone=true;
					//P=LPstart;
					P+=2;
					fShake=true;
					fAdd=false;//无需递增
				}
			}
			//--第3,6款车载端
			if((0x02==mode)||(0x05==mode))
			{
				if((SHck==P)&&(false==fDone))//需要检查而且行标一致
				{
					//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					CString strTemp;
					strTemp.LoadString(NULL,IDS_WaitInsertKey);
					pStatusBar->SetText(strTemp,0,0);
					pProgress->SetRange(0,0x80);   //设置进度条的范围为0-1000	
					pProgress->SetPos(0x80);
					pProgress->UpdateWindow();
					fDone=true;
				}
			}
			//--第5,7,8,9款车载端
			if((0x04==mode)||(0x06==mode)||(0x07==mode)||(0x08==mode))
			{
				if((SUend==P)&&(false==fDone))
				{
					fDone=true;
					SUcnt++;
					if(SUcnt>0x10)
					{
// 							DspRead="Error shake 5";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult=HIDResult_CANErr;
						return;
					}
					else
					{
						P=SUstart;
						fAdd=false;//无需递增
					}
				}
			}
			//---------------------------
			//---public
			if(false==fDone)
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 						DspRead="Error wr N5";//后续写的时候跟据车载端选择和进度做为错误代码
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					//pResult->hidResult=HIDResult_CANErr;
					pResult->hidResult=HIDResult_ReadEZSError6;
					return;
				}
				else
				{
					fAdd=false;//无需递增
					Wake++;
					if(Wake>0x20)
					{
// 							DspRead="Error 唤醒";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
						//pResult->hidResult=HIDResult_CANErr;
						pResult->hidResult=HIDResult_ReadEZSError6;
						return;
					}
				}
			}				//---------------------------
			//}
			//---public			
		}
		if(true==fAdd)
		{
			P++;
		}
	}

	pResult->hidResult=HIDResult_OK;
	VMProtectEnd();
}

void CHIDWork::RenewEZS( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,byte* pSSID,byte* pDPass,byte* pPass)
{
	VMProtectBegin("HIDWork6");
	int i;
	bool Shk=false;
	int OVchk=0;


	unsigned char Rnew[32];//

	byte EZS_a[0x02][0x10]={
		{0x03,0x50,0x00,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x1E,0x01},
		{0x03,0x53,0x77,0x09,0x4F,0x88,0x37,0x44,0x7C,0xF9,0x00,0x00,0x00,0x09,0x50,0x01},
	};

	byte RN_chk[0x10]=
		{0x0A,0x68,0x00,0x17,0x50,0x00,0xBB,0x85,0x52,0xDF,0x0A,0x00,0x00,0x00,0x00,0x00};
		
	//
	for(i=0;i<0x04;i++)
	{		
		EZS_a[0x00][i+0x03]=pSSID[i];
	}
	//
	//for(i=0;i<0x08;i++)
	//{
	//	Rnew[i]=DLER[i];
	//}
	
	for(i=0;i<0x08;i++)
	{
		//设置renew密码
		Rnew[i]=pDPass[i];
	}
	for(i=0;i<0x08;i++)
	{
		//设置密码
		Rnew[i+0x08]=pPass[i];
	}
	for(i=0;i<0x06;i++)
	{
		Rnew[i+0x10]=EZS_a[0x00][i+0x01];
	}

	//
	CInteractionData tx;
	CInteractionData rx;
	CString strTemp;
	strTemp.LoadString(NULL,IDS_WaitInsertKey);
	pStatusBar->SetText(strTemp,0,0);
	pProgress->SetRange(0,200);
	pProgress->SetPos(200);
	while(true!=Shk)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=EZS_a[0][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			if(0x63!=rx.buff[0x11])
			{
				pResult->hidResult=HIDResult_RENEWError_a2;
				return;
			}
			Shk=true;
		}		
		else
		{
// 			DspRead="waiting insert device KEY";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		//
		if(OVchk>200)
		{
			pResult->hidResult=HIDResult_InsertKeyTimeOut;
			//MessageBox("Read Error","Read",MB_OK);
			return;
		}
		else
		{
			OVchk++;
			pProgress->SetPos(200-OVchk);
			pProgress->UpdateWindow();
		}
		//------------------

	}
	//--
	for(i=0;i<0x09;i++)
	{
		Rnew[i+0x16]=rx.buff[i+0x11];
	}
	CPassCalc cpCalc;
	cpCalc.sub_CALrenew(Rnew);//此处应为调用加密狗计算
	for(i=0;i<8;i++)
	{
		EZS_a[0x01][0x02+i]=cpCalc.HashOut[i];
	}
// 	for(i=0;i<5;i++)
// 	{
// 		RN_chk[0x06+i]=cpCalc.HashOut[i];
// 	}
	for(i=0;i<5;i++)
	{
		RN_chk[0x06+i]=pDPass[i];
	}
	tx.Init();
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
		
	for(i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=EZS_a[1][i];
	}		
	rx = DeviceInteraction(tx);
	pProgress->SetRange(0,200);
	pProgress->SetPos(200);
	pProgress->UpdateWindow();
	if (!rx.bOK)
	{
		pResult->hidResult= HIDResult_USBError;
		return;
	}
	else if (rx.CheckDataList() == false)
	{
		pResult->hidResult= HIDResult_RxError;
		return;
	}
	else if (rx.buff[1] == 0x00)
	{
		
	}
	else
	{
		pResult->hidResult= HIDResult_RenewError_b;
		return;
	}
	for(i=0;i<RN_chk[0x00];i++)
	{
		if(RN_chk[i+0x01]!=rx.buff[i+0x11])
		{
			pResult->hidResult= HIDResult_RenewError_b;
			return;
		}
	}
	pResult->hidResult=HIDResult_OK;	
	VMProtectEnd();
}
byte* CHIDWork::ISMReadInfo(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork_ISMReadInfo");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;	

	byte* tmpRX=new byte[0x101];
	int m;
	int P;
	//unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x03,0x7F,0x10,0x12,0x00,0x00,0x00,0x00};//马牌
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//西门子
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_ISM[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//01
		//----马牌
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//04
		//--
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//05

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//06
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//07

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//08
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//09

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x03,0x22,0xF1,0x21,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//0A
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},//0B

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//0C
		//----<
		//----西门子
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//0D
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//0E

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x1A,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//0F
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//10

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x1A,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//11
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x03},//12

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x1A,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//13
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x03},//14
		//----<
		//--STOP
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//15
	};	
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x06);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		tx.buff[0x0F]=0x06;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_ISM[P][i];
			tptx[i]=RD_ISM[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		
		}
		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x15;
// 					DspRead="read ISM error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x15;
// 					DspRead="read ISM error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					tmpRX[0x100]=0;//马牌
					P=0x02;
// 					DspRead="read ISM mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//return NULL;
				}
				if((false==fRUa)&&(true==fRUb))
				{
					tmpRX[0x100]=1;//西门子
					P=0x0E;//0x0D
// 					DspRead="read ISM mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//return NULL;
				}
				break;
				//------
			case 0x02://马牌 再次判断
				fAdd=false;//无需递增
				fRUa=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
				}
				if(true==fRUa)
				{
					cntA++;
					if(cntA>0x07)
					{
						fAdd=true;//递增
						cntA=0;
					}
				}
				break;
				//------
			case 0x03://暂时不做判断，默认下一步

				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x06://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x07://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x08://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------		
			case 0x09://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x0A://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------	
			case 0x0B://
				for(i=0;i<0x18;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				fOK=true;
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism INFO OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//return NULL;
				break;
				//------
				//------
				//------

			case 0x0D://西门子 再次判断
				fAdd=false;//无需递增
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					cntB++;
					if(cntB>0x02)
					{
						fAdd=true;//递增
						cntB=0;
					}
				}
				break;
				//------
			case 0x0E://不知用途，空操作

				break;
				//------
			case 0x0F://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x10://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x11://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;	
				//------
			case 0x12://
				for(i=0;i<0x18;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				k++;
				break;	
				//------
			case 0x13://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;	
				//------
			case 0x14://
				for(i=0;i<0x18;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				//	k++;
				//	k++;
				fOK=true;
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism INFO OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//return NULL;
				break;		
				//------
				//------
			case 0x15:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//return NULL;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				cntA++;
				if(cntA>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x15;
// 					DspRead="read ism overtime 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
				}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x08://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 08";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x09://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 09";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
			case 0x0A://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 0A";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x0B://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 0B";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------			
				//------
				//------
			case 0x0D://西门子 再次判断
				cntB++;
				if(cntB>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x15;
// 					DspRead="read ism overtime 0D";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
				}
				//------
			case 0x0E://不知用途，空操作

				break;
				//------
			case 0x0F://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 0F";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x10://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 10";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x11://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x12://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x13://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x14://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="read ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			case 0x15://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				fSTP=true;//跳出循环
// 				DspRead="read ism overtime 15";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x15)
			{
				fSTP=true;//超限，跳出循环
			}			
		}
		pProgress->SetPos(k);
		pProgress->UpdateWindow();
		//------------------
	}
	//------------------
	if(pResult->hidResult==HIDResult_OK)
		return tmpRX;
	else
		return NULL;
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	VMProtectEnd();
}
byte* CHIDWork::ISMReadData(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork_ISMReadData");
	pResult->hidResult=HIDResult_OK;
	int i;
	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x03,0x7F,0x10,0x12,0x00,0x00,0x00,0x00};//马牌
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//西门子
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_ISM[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//01
		//----马牌
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//04
		//--
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//05

		{0x01,0x5F,0xC0,0x5E,0xC0,0x08,0x43,0x76,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//06//加入循环值00--0B,09位置
		{0x0A,0x5F,0xC0,0x5E,0xC0,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//07//纯接收，收到4C忽略，05存储
		{0x0A,0x5F,0xC0,0x5E,0xC0,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//08//纯接收05忽略，超时没收到即代表发送结束

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//09
		//----<
		//----西门子
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//0A
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//0B

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//0C

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x00,0xFF,0xFF,0x00,0x02},//0D//加入循环值00--0B,0B位置
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x00,0xFF,0xFF,0x00,0x00},//0E//加入循环值00--0B,0B位置
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//0F
		//----<
		//--STOP
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//10
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//11
	};	
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x0b);
	pProgress->SetPos(0);
	int nRetry_0D=10;
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;
		//
		if((0x06==P)||(0x0D==P)||(0x0E==P))
		{
			RD_ISM[0x06][0x09]=k;
			RD_ISM[0x0D][0x0B]=k;
			RD_ISM[0x0E][0x0B]=k;
		}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_ISM[P][i];
			tptx[i]=RD_ISM[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		}
		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
// 					return;
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
// 					return;
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x02;
					//	fAdd=true;//递增
// 					DspRead="read ISM mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x0B;//0x0A
					//	fAdd=true;//递增
// 					DspRead="read ISM mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x02://马牌 再次判断
				fAdd=false;//无需递增
				fRUa=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
				}
				if(true==fRUa)
				{
					cntA++;
					if(cntA>0x07)
					{
						fAdd=true;//递增
						cntA=0;
					}
				}
				break;
				//------
			case 0x03://暂时不做判断，默认下一步

				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://暂时不做判断，默认下一步

				break;
				//------
			case 0x06://接收4C开头数据，并提取3个字节，
				if(0x4C==tprx[0x00])
				{
					tmpRX[0x10*k+0x00]=tprx[0x05];
					tmpRX[0x10*k+0x01]=tprx[0x06];
					tmpRX[0x10*k+0x02]=tprx[0x07];
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 03";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x07://接收并提取5个字节，
				if((0x4C==tprx[0x00])||(0x05==tprx[0x00]))
				{
					if(0x05==tprx[0x00])
					{
						cntA=0;
						tmpRX[0x10*k+0x03]=tprx[0x01];
						tmpRX[0x10*k+0x04]=tprx[0x02];
						tmpRX[0x10*k+0x05]=tprx[0x03];
						tmpRX[0x10*k+0x06]=tprx[0x04];
						tmpRX[0x10*k+0x07]=tprx[0x05];
					}
					else
					{
						fAdd=false;//无需递增
						cntA++;
						if(cntA>0x40)
						{
							cntA=0;
							//	fAdd=false;//无需递增
							P=0x11;
// 							DspRead="read ISM error 05";//错误退出
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							pResult->hidResult= HIDResult_ReadError;
							return NULL;
						}
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 04";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x08://接收05开头数据
				if(0x05==tprx[0x00])
				{
					fAdd=false;//无需递增
					cntA++;
					if(cntA>0x40)
					{
						cntA=0;
						//	fAdd=false;//无需递增
						P=0x11;
// 						DspRead="read ISM error 07";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult= HIDResult_ReadError;
						return NULL;
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 06";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x09://
				fOK=true;
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
				//------
			case 0x0A://西门子 再次判断
				fAdd=false;//无需递增
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					cntB++;
					if(cntB>0x02)
					{
						fAdd=true;//递增
						cntB=0;
					}
				}
				break;
				//------
			case 0x0B://不知用途，空操作

				break;
				//------
			case 0x0C://暂时不做判断，默认下一步

				break;
				//------
			case 0x0D://暂时不做判断，默认下一步
				fAdd=false;//无需递增
				P=0x0F;
				break;
				//------
			case 0x0E://暂时不做判断，默认下一步

				break;
				//------
			case 0x0F://接收21开头数据，并提取8个字节，
				if((0x21==tprx[0x00])&&(0x22==tprx[0x08]))
				{
					tmpRX[0x10*k+0x00]=tprx[0x01];
					tmpRX[0x10*k+0x01]=tprx[0x02];
					tmpRX[0x10*k+0x02]=tprx[0x03];
					tmpRX[0x10*k+0x03]=tprx[0x04];
					tmpRX[0x10*k+0x04]=tprx[0x05];
					tmpRX[0x10*k+0x05]=tprx[0x06];
					tmpRX[0x10*k+0x06]=tprx[0x07];
					tmpRX[0x10*k+0x07]=tprx[0x09];
					//
					k++;
					if(k>0x0B)
					{
						fAdd=false;//无需递增
						//fSTP=true;//跳出循环
						P=0x11;
// 						DspRead="read ism OK";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					else
					{
						fAdd=false;//无需递增
						P=0x0D;
// 						DspRead="read next";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x11;
// 					DspRead="read ISM error 0F-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------

				//------
			case 0x11:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				cntA++;
				if(cntA>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
// 					DspRead="read ism overtime 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
				}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x08://
				k++;
				if(k>0x0B)//0x0B
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x09;
					//	DspRead="read ism OK";//错误退出
					//	SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					P=0x05;
					//DspRead="read next";//错误退出
					//SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x09://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 09";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			case 0x0A://西门子 再次判断
				cntB++;
				if(cntB>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x11;
// 					DspRead="read ism overtime 0A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
				}
				//------
			case 0x0B://不知用途，空操作

				break;
				//------
			case 0x0C://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 0C";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x0D://
				fAdd=false;//无需递增
				nRetry_0D--;
				if(nRetry_0D==0)
				{
					P=0x11;
					pResult->hidResult= HIDResult_ReadError;
				}


				//fSTP=true;//跳出循环
				
// 				DspRead="read ism overtime 0D";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				
				break;
				//------
			case 0x0E://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 0E";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x0F://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x11;
// 				DspRead="read ism overtime 0F";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------



				//------
			case 0x11://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				fSTP=true;//跳出循环
// 				DspRead="read ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x11)
			{
				fSTP=true;//超限，跳出循环
			}			
		}
		pProgress->SetPos(k);
		pProgress->UpdateWindow();
		//------------------
	}
	//------------------
	if(pResult->hidResult==HIDResult_OK)		
		return tmpRX;
	else 
		return NULL;
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	VMProtectEnd();
}
void CHIDWork::ISMRenew(byte* pDS, CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork_ISMRenew");
	pResult->hidResult=HIDResult_OK;
	int i;
	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x03,0x7F,0x10,0x12,0x00,0x00,0x00,0x00};//马牌
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//西门子
	const unsigned char rdy[0x08]={0x03,0x7F,0x31,0x78,0xFF,0xFF,0xFF,0xFF};//西门子 准备好
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	//unsigned char DS[0x08]={0xFE,0xB3,0x53,0xE9,0x4C,0x48,0x11,0x48};//后续通过服务器或界面输入获得数据，暂固定化

	byte RN_ISM[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//01
		//----马牌
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//04--ID 114
		//--
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//05--发5遍	

		{0x01,0x5F,0xC0,0x93,0xA0,0x08,0x4A,0x52,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//06--发部分DEALER 5
		{0x01,0x5F,0xC0,0x93,0xA0,0x08,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//07--发部分DEALER 3

		{0x08,0xDD,0x40,0x5E,0xC0,0x08,0x02,0x3E,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//08--查询结果
		//----<
		//----西门子
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//09
		{0x08,0x22,0x80,0x93,0xA0,0x08,0x43,0x76,0x05,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//0A--ID 114

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//0B--发5遍
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x0B,0xFF,0xFF,0x00,0x01},//0C--判断是否准备好
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x0B,0xFF,0xFF,0x00,0x01},//0D--读状态字
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//0E--继续读状态字

		{0x01,0x5F,0xC0,0x93,0xA0,0x08,0x4A,0x52,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0F--发部分DEALER 5
		{0x01,0x5F,0xC0,0x93,0xA0,0x08,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//10--发部分DEALER 3

		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x02,0x3E,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//11--发5遍
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x0B,0xFF,0xFF,0x00,0x01},//12--判断是否准备好
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x05,0x31,0x43,0x76,0x04,0x0B,0xFF,0xFF,0x00,0x01},//13--读状态字
		{0x01,0xDD,0x40,0x93,0xA0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//14--继续读状态字
		//----<
		//--STOP
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//15
	};
	
	//---
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//--载入DISDEALER
	RN_ISM[0x06][0x09]=pDS[0];
	RN_ISM[0x06][0x0A]=pDS[1];
	RN_ISM[0x06][0x0B]=pDS[2];
	RN_ISM[0x06][0x0C]=pDS[3];
	RN_ISM[0x06][0x0D]=pDS[4];
	RN_ISM[0x07][0x07]=pDS[5];
	RN_ISM[0x07][0x08]=pDS[6];
	RN_ISM[0x07][0x09]=pDS[7];
	//
	RN_ISM[0x0F][0x09]=pDS[0];
	RN_ISM[0x0F][0x0A]=pDS[1];
	RN_ISM[0x0F][0x0B]=pDS[2];
	RN_ISM[0x0F][0x0C]=pDS[3];
	RN_ISM[0x0F][0x0D]=pDS[4];
	RN_ISM[0x10][0x07]=pDS[5];
	RN_ISM[0x10][0x08]=pDS[6];
	RN_ISM[0x10][0x09]=pDS[7];
	//
	//--
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x15);
	pProgress->SetPos(0);
	int wfRetry=0;
	byte wfx[10];
	bool b22=false;
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RN_ISM[P][i];
			tptx[i]=RN_ISM[P][i];
		}		
		wfx[0]=P;
		Rx=tx.buff[0x1F];
		TRACE("\r\n发送");
		TRACE(CCommFunc::byteToHexStr(wfx,1,_T(" ")));
		TRACE("：---------------\r\n");
		TRACE(CCommFunc::byteToHexStr(tx.buff,0x40,_T(" ")));
		rx = DeviceInteraction(tx);
		TRACE("\r\n接收：---------------\r\n");
		TRACE(CCommFunc::byteToHexStr(rx.buff,0x40,_T(" ")));
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{}

		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x15;
// 					DspRead="read ISM error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
					return;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x15;
// 					DspRead="read ISM error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
					return;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x02;
// 					DspRead="read ISM mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//pResult->hidResult= HIDResult_RenewError;
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x0A;//0x09
// 					DspRead="read ISM mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
			case 0x02://马牌 再次判断
				fAdd=false;//无需递增
				fRUa=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
				}
				if(true==fRUa)
				{
					cntA++;
					if(cntA>0x07)
					{
						fAdd=true;//递增
						cntA=0;
					}
				}
				break;
				//------
			case 0x03://暂时不做判断，默认下一步

				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				fRUa=true;
				cntA++;
				if(cntA>0x04)
				{
					fAdd=true;//递增
					cntA=0;
				}
				break;
				//------
			case 0x06://

				break;
				//------
			case 0x07://

				break;
				//------
			case 0x08://
				fAdd=false;//无需递增
				P=0x15;
				if(0x00==(tprx[0x05]&0x0F))
				{
					fOK=true;
// 					DspRead="renew ism OK";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fOK=false;
// 					DspRead="renew ism fail";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
				//------
				//------
				//------
			case 0x09://西门子 再次判断
				fAdd=false;//无需递增
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					cntB++;
					if(cntB>0x02)
					{
						fAdd=true;//递增
						cntB=0;
					}
				}
				break;
				//------
			case 0x0A://不知用途，空操作

				break;
				//------
			case 0x0B://
				fAdd=false;//无需递增
				cntB++;
				if(cntB>0x04)
				{
					fAdd=true;//递增
					cntB=0;
				}
				break;
				//------
			case 0x0C://
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=rdy[i])
					{
						fRUb=false;
					}
				}
				if(tprx[3]==0x22)
				{
					RN_ISM[0x0f][0x02]=0x22;
					RN_ISM[0x0f][0x03]=0x80;

					RN_ISM[0x10][0x02]=0x22;					
					RN_ISM[0x10][0x03]=0x80;
				}
				if(true==fRUb)
				{
					fAdd=false;//无需递增
					P=0x0e;
					wfRetry=0;
// 					DspRead="ism ready";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					wfRetry++;
					if(wfRetry>100)
					{
						fAdd=false;//无需递增
						P=0x15;
						pResult->hidResult= HIDResult_RenewError;
					}
					else
					{
						fAdd=false;//无需递增
						P=0x0c;
					}
// 					DspRead="ism busy";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x0D://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10+i]=tprx[i];
				}
				break;	
				//------
			case 0x0E://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x20+i]=tprx[i];
				}
				break;	
				//------
			case 0x0F://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x20+i]=tprx[i];
				}
				break;	
				//------
			case 0x10://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x20+i]=tprx[i];
				}
				break;	
				//------
			case 0x11://
				fAdd=false;//无需递增
				cntB++;
				if(cntB>0x04)
				{
					fAdd=true;//递增
					cntB=0;
				}
				break;
				//------
			case 0x12://
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=rdy[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					fAdd=false;//无需递增
					P=0x14;
// 					DspRead="ism ready";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					cntB++;
					if(cntB>0x80)
					{
						P=0x15;
// 						DspRead="ism busy";//
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				break;
				//------
			case 0x13://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x30+i]=tprx[i];
				}
				break;	
				//------
			case 0x14://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x40+i]=tprx[i];
				}
				if(0x00==(tprx[0x02]&0x0C))
				{
					fOK=true;
// 					DspRead="renew ism OK";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fOK=false;
// 					DspRead="renew ism fail";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
				}
				fAdd=false;//无需递增
				P=0x15;
				break;	
				//------
				//------
				//------
			case 0x15:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x01://
				cntA++;
				if(cntA>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x15;
// 					DspRead="renew ism overtime 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x04://不知用途，空操作

				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x08://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 08";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
				//------			
				//------
				//------
			case 0x09://西门子 再次判断
				cntB++;
				if(cntB>0x07)
				{
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x15;
					pResult->hidResult= HIDResult_RenewError;
// 					DspRead="renew ism overtime 09";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				//------
			case 0x0A://不知用途，空操作

				break;
				//------
			case 0x0B://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 0B";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0C://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 0C";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0D://
				fAdd=false;//无需递增
				P=0x15;
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0E://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 0E";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0F://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 0F";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x10://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 10";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x11://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 11";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x12://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 12";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x13://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 13";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x14://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x15;
// 				DspRead="renew ism overtime 14";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
				//------
				//------
			case 0x15://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				fSTP=true;//跳出循环
// 				DspRead="read ism overtime 15";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x15)
			{
				fSTP=true;//超限，跳出循环
			}
			pProgress->SetPos(P);
			pProgress->UpdateWindow();
		}
		//------------------
	}
	pProgress->SetPos(0x16);
	pProgress->UpdateWindow();
	//------------------
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	//return tmpRX;
	VMProtectEnd();
}
byte* CHIDWork::ESLReadInfo(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork7");
	// TODO: Add your control notification handler code here
	int i;
	byte* tmpRX=new byte[0x80];//tp[0x10];
	unsigned char Sum,TS;
	int m;
	int P;
	unsigned char Rx;
	unsigned char x,y,TA,TB;

	//第1款
	byte uart_INFO[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x76,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x0B,0x00,0x0B},
	};
	const byte Cmd[0x03]={0x90,0x91,0xC7};
	bool fRD=false;

	//---
	for(i=0;i<0x80;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	m=0x00;
	P=0;
	//--m 可用作进度条变量
	fRD=false;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x02);
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	while(false==fRD)
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_INFO[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			tx.buff[0x13]=Cmd[m];
			x=0x78;
			y=Cmd[m];
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
			pResult->hidResult= HIDResult_CANErr;
			return NULL;
// 			DspRead="接收超时";//
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			MessageBox("接收超时","Read",MB_OK);
			
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
// 				DspRead="校验错误1";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误1","Read",MB_OK);
// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return NULL;
			}
			TA=rx.buff[0x11];
			TB=rx.buff[0x12];
			if((x!=TA)||(y!=TB))
			{
// 				DspRead="校验错误2";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误2","Read",MB_OK);
// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return NULL;
			}			
			//for(i=0;i<(Rx-0x01);)
			for(i=0;i<0x08;i++)
			{
				tmpRX[m*0x10+i]=rx.buff[i+0x13];
			}
			m++;
			pProgress->SetPos(m);
			pProgress->UpdateWindow();
			if(m>=0x03)
			{
// 				DspRead="读INFO完成";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				fRD=true;
			}
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	return tmpRX;
	VMProtectEnd();
}

byte* CHIDWork::ESLReadData(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork8");
	int i;
	byte* tmpRX=new byte[0x400];
	unsigned char Sum,TS;
	int m;
	int P;
	unsigned char Rx;
	unsigned char x,y,TA,TB;

	//第1款
	byte uart_INFO[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x0B,0x00,0x0B},
	};
	const byte Cmd[0x34]={
		0x00,0x01,0x02,0x03,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x23,0x30,0x31,0x32,0x33,
		0x40,0x41,0x42,0x43,0x50,0x51,0x52,0x53,0x60,0x61,0x62,0x63,0x70,0x71,0x72,0x73,
		0x80,0x81,0x82,0x83,0x90,0x91,0x92,0x93,0x94,0xA0,0xB0,0xC0,0xC2,0xC3,0xC5,0xC7,
		0xC8,0xC9,0xCA,0xCB,};
		//
	bool fRD=false;

		
	for(i=0;i<0x400;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	m=0x00;
	P=0;
	//--m 可用作进度条变量
	fRD=false;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x33);
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	while(false==fRD)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_INFO[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			tx.buff[0x13]=Cmd[m];
			x=0x78;
			y=Cmd[m];
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
// 			DspRead="接收超时";//
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			MessageBox("接收超时","Read",MB_OK);
			pResult->hidResult=HIDResult_CANErr;
			return NULL;
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
// 				DspRead="校验错误1";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误1","Read",MB_OK);
				pResult->hidResult=HIDResult_CANErr;
				return NULL;
			}
			TA=rx.buff[0x11];
			TB=rx.buff[0x12];
			if((x!=TA)||(y!=TB))
			{
// 				DspRead="校验错误2";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误2","Read",MB_OK);
				pResult->hidResult=HIDResult_CANErr;
				return NULL;
			}			
			//for(i=0;i<(Rx-0x01);)
			for(i=0;i<0x08;i++)
			{
				tmpRX[m*0x08+i]=rx.buff[i+0x13];
			}
			m++;
			pProgress->SetPos(m);
			pProgress->UpdateWindow();
			if(m>=0x34)
			{				
// 				DspRead="读EE完成";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				fRD=true;
			}
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	return tmpRX;
	VMProtectEnd();
}

void CHIDWork::ESLWrite( CProgressCtrl* pProgress,CInteractionData* pResult,byte* pBuf,byte* cPSW)
{	
	VMProtectBegin("HIDWork9");
	int i,j;
	unsigned char tp[0x10];
	unsigned char Sum,TS;
	int m;
	int P;
	unsigned char Rx;
	//unsigned char x,y,TA,TB;

	//第1款
	byte uart_WR[0x04][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x0B,0x00,0x0B},
	};
	//unsigned char cPSW[0x08]={0x7C,0x8F,0xB3,0xD8,0xC7,0x3E,0xA5,0xCE};//此密码需要服务器计算获得，此处用固定值测试
// 	CInputPSW ipsw;
// 	ipsw.DoModal();
// 	CString strTemp;
// 	if(!ipsw.bPSW)
// 	{
// 		strTemp.LoadString(NULL,IDS_ServerTip11);
// 		MessageBox(strTemp);
// 		pResult->hidResult= HIDResult_RxError;
// 		return;
// 	}
// 	for(int xx=0;xx<8;xx++)
// 		cPSW[xx]=ipsw.PSW[xx];
	unsigned char TXbuf[0x11][0x0B]={
		{0x15,0x01,0x7C,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00},//0
		{0x96,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1
		{0x96,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//2
		{0x96,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//3
		{0x96,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//4
		{0x96,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//5
		{0x96,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//6
		{0x96,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//7
		{0x96,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//8
		{0x96,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//9
		{0x96,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//A--psw
		{0x96,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//B--sum all
		{0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//C
		{0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//D
		{0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//E
		{0x9A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//F
		{0x9A,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0
	};
	unsigned char RXbuf[0x11][0x0B]={
		{0x8A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0
		{0x8B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1
		{0x8B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//2
		{0x8B,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//3
		{0x8B,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//4
		{0x8B,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//5
		{0x8B,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//6
		{0x8B,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//7
		{0x8B,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//8
		{0x8B,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//9
		{0x8B,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//A
		{0x8B,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//B
		{0xA1,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//C
		{0xA1,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//D
		{0xA1,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//E
		{0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//F
		{0x98,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0
	};
	unsigned char SumH,SumL;
	bool fWR=false;
	bool fSam=false;	
	for(j=0;j<8;j++)
	{
		for(i=0;i<8;i++)
		{
			TXbuf[j+0x01][i+0x02]=pBuf[0x270+0x10*j+i];
		}
	}
	//
	for(i=0;i<8;i++)
	{
		TXbuf[0x09][i+0x02]=pBuf[0x10+i];//delaer
	}
	//
	for(i=0;i<8;i++)
	{
		TXbuf[0x0A][i+0x02]=cPSW[i];//cPSW
	}
	//
	for(j=0;j<3;j++)
	{
		TXbuf[j+0x0C][0x02]=pBuf[0x02];
		TXbuf[j+0x0C][0x03]=pBuf[0x00];
		TXbuf[j+0x0C][0x06]=pBuf[0x03];
		TXbuf[j+0x0C][0x09]=pBuf[0x01];
	}
	//
	for(i=0;i<7;i++)
	{
		TXbuf[0x0F][i+0x02]=pBuf[0x303+i];
	}
	for(i=0;i<6;i++)
	{
		TXbuf[0x10][i+0x02]=pBuf[0x30A+i];
	}
	TXbuf[0x10][0x08]=pBuf[0x310];
	//--
	for(j=0;j<0x11;j++)
	{
		Sum=0x00;
		for(i=0;i<0x0A;i++)
		{
			Sum+=TXbuf[j][i];
		}
		TXbuf[j][0x0A]=Sum;
	}
	//
	SumH=0x00;
	SumL=0x00;
	for(j=0;j<0x0A;j++)
	{
		for(i=0;i<0x08;i++)
		{
			if((SumL+TXbuf[j+0x01][i+0x02])>0xFF)
			{
				SumH++;
			}
			SumL+=TXbuf[j+0x01][i+0x02];
		}
	}
	TXbuf[0x0B][0x09]=SumH;
	TXbuf[0x0B][0x08]=SumL;
	TXbuf[0x0B][0x0A]=TXbuf[0x0B][0x0A]+SumH+SumL;//总校验包的校验和
	
	//---接收比较缓存整理
	CPassCalc cpCalc;
	for(j=0;j<0x0B;j++)
	{
		for(i=0;i<0x08;i++)
		{
			cpCalc.HashIn[i]=TXbuf[j+0x01][i+0x02];
		}
		cpCalc.sub_HashOnce();
		for(i=0;i<0x08;i++)
		{
			RXbuf[j+0x01][i+0x02]=cpCalc.HashOut[i];
		}
	}
	//
	for(j=0;j<3;j++)
	{
		RXbuf[j+0x0C][0x02]=pBuf[0x02];
		RXbuf[j+0x0C][0x03]=pBuf[0x00];
		RXbuf[j+0x0C][0x06]=pBuf[0x03];
		RXbuf[j+0x0C][0x09]=pBuf[0x01];
	}
	//---	
	m=0x00;
	P=0;
	//--m 可用作进度条变量
	fWR=false;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x10);	
	while(false==fWR)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_WR[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			for(i=0;i<0x0B;i++)
			{
				tx.buff[0x11+i]=TXbuf[m][i];
			}
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
// 			DspRead="接收超时";//
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			MessageBox("接收超时","Read",MB_OK);
			pResult->hidResult= HIDResult_CANWriteWait;
			return;
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
				tp[i]=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
// 				DspRead="校验错误1";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误1","Read",MB_OK);
				pResult->hidResult= HIDResult_CANWriteWait;
				return;
			}
			fSam=true;
			for(i=0;i<0x0A;i++)//0x0A
			{
				if(tp[i]!=RXbuf[m][i])//tp[i]!=RXbuf[m][i]
				{
					if(((m==0x0C)||(m==0x0D)||(m==0x0E)||(m==0x10))&&(i==0x01))
					{}
					else
					{
						fSam=false;
					}
				}
			}
			if(false==fSam)
			{
// 				DspRead="校验错误2";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误2","Read",MB_OK);
				pResult->hidResult= HIDResult_CANWriteWait;
				return;
			}
			m++;
			pProgress->SetPos(m);
			pProgress->UpdateWindow();
			if(m>=0x11)
			{
// 				DspRead="写EE完成";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				fWR=true;
			}
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	pResult->hidResult= HIDResult_OK;
	VMProtectEnd();
}
void CHIDWork::ESLRenew(byte* pPSW, CInteractionData* pResult )
{
	VMProtectBegin("HIDWork10");
	int i;

	//	unsigned char tmpRX[0x80];
	unsigned char Sum,TS;
	int P;
	unsigned char Rx;

	//第1款
	byte uart_RNEW[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x52,0x00,0xBB,0x00,0x00,0x00,0x00,0x00,0x00,0xD6,0x00,0x10,0x0B,0x00,0x0B},
	};
	//	const char Cmd[0x03]={0x90,0x91,0xC7};
	const byte TA[0x0A]={0x77,0x03,0x79,0x52,0x00,0x00,0x00,0x00,0x00,0x00};
	const byte TB[0x0A]={0x77,0x03,0x79,0x52,0xFF,0x00,0x00,0x00,0x00,0x00};
	unsigned char tp[0x0A];
	bool fSam=false;
	bool fRN=false;	

	//--载入打开的文件进行数据传送，后续开发要更改为自动填入服务器算得的结果，也是8字节
	for(i=0;i<0x08;i++)
	{
		uart_RNEW[0x02][i+0x03]=pPSW[i];
	}
	//--
	//
	P=0;
	//--P 可用作进度条变量
	fRN=false;
	CInteractionData tx;
	CInteractionData rx;
	while(false==fRN)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_RNEW[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
			// 			DspRead="RENEW密码错误";//
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			// 			MessageBox("RENEW密码错误","Read",MB_OK);
			// 			return;
			pResult->hidResult= HIDResult_CANErr;
			return;
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
				tp[i]=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
				// 				DspRead="校验错误1";//
				// 				SetDlgItemText(IDC_EDIT11, DspRead);
				// 				MessageBox("校验错误1","Read",MB_OK);
				// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return;
			}
			//
			fSam=true;
			for(i=0;i<0x0A;i++)
			{
				if(tp[i]!=TA[i])
				{
					fSam=false;
				}
			}
			if(true==fSam)
			{
				// 				DspRead="RENEW完成";//
				// 				SetDlgItemText(IDC_EDIT11, DspRead);
				// 				MessageBox("RENEW完成","Read",MB_OK);
				fRN=true;
			}
			else
			{
				fSam=true;
				for(i=0;i<0x0A;i++)
				{
					if(tp[i]!=TB[i])
					{
						fSam=false;
					}
				}
				if(true==fSam)
				{
					// 					DspRead="RENEW无效";//
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					// 					MessageBox("RENEW无效","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					fRN=true;
					//return;
				}
				else
				{
					// 					DspRead="RENEW未知错误";//
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					// 					MessageBox("RENEW未知错误","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return;
				}
			}		
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	VMProtectEnd();
}
byte* CHIDWork::SuanMiMa( HWND hWnd, int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,bool* bRun)
{
	VMProtectBegin("HIDWork111");
	// TODO: Add your control notification handler code here
	int i;
	CString strTemp,strTemp1;
	DWORD     dwStart,dwCur,dwTime;	
	CString str;
	//------------
	const byte CAN_dtA[0x10]={0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//500k
	//const char CAN_dtB[0x10]={0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//83.3k
	bool fDut=false;//波特率重试标识；每次点下按钮，仅重试1次后。

	const byte RDcmd[0x0A]={0x00,0x01,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E};

	//第1款--无错误动态字发生
	const byte CANm_A[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANm_B[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANm_C[0x06][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANm_D[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANm_E[0x07][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANm_G[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANm_H[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//---加步


	char tmpRX[0x800];
	int m;
	int j;
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;
	unsigned char cnt1=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Td[0x10]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x0A,0x06,0x08,0x1A,0x00,0x00},//1--无错误
		{0x07,0x03,0x05,0x1C,0x00,0x00},//2--无错误
		{0x06,0x03,0x04,0x1C,0x01,0x03},//3--
		{0x07,0x03,0x05,0x1A,0x00,0x00},//4--无错误
		{0x07,0x03,0x05,0x1C,0x01,0x04},//5--
		{0x06,0x03,0x04,0x1C,0x01,0x03},//6--
		{0x07,0x03,0x05,0x1C,0x01,0x04},//7
		{0x07,0x03,0x05,0x1C,0x01,0x04},//8
		{0x07,0x03,0x05,0x1C,0x01,0x04},//9
	};
	unsigned char rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];//加入动态命令字的位置
	JC = rdEEDT[mode][0x05];//需要检查的行标

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
	//-------------------------
	const char TS[0x09][0x04]={
		{0x06,0x02,0x09,0x06},//1--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//3--
		{0x06,0x02,0x09,0x06},//4--
		{0x01,0x07,0x09,0x01},//5--
		{0x01,0x07,0x09,0x01},//6--
		{0x01,0x07,0x09,0x01},//7--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];
	//
	bool fSame=false;
	unsigned char readA[0x10],readB[0x10],readC[0x10],readD[0x10];
	unsigned char outBuf[0x800];
	//-------------------------
	switch(mode)
	{
		//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_A[j][i];
			}
		}
		break;
		//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_B[j][i];
			}
		}
		break;
		//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_C[j][i];
			}
		}
		break;
		//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_D[j][i];
			}
		}
		break;
		//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_E[j][i];
			}
		}
		break;
		//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_G[j][i];
			}
		}
		break;
		//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_H[j][i];
			}
		}
		break;
		//------
		//------
	default:
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//--------------------
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip1,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("1"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	CInteractionData tx;
	CInteractionData rx;
	// 	CString strTemp;
	// 	strTemp.LoadString(IDS_WaitInsertKey);
	//	pStatusBar->SetText(strTemp,0,0);
	// 	pProgress->SetRange(0,200);
	// 	pProgress->SetPos(200);
	//--------------------
	//以下程序如果可以做成模块调用会很方便，因不会在子程序中弹出窗口和操作显示基础操作等等，
	//所以写了4遍，完全一样，仅仅是调用后把数据取出后的操作不同，
	//此处即使做成模块也要用线程操作，P值的变化可以做成进度条或闪烁功能
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		//--
		if(0x00==rx.buff[1])
		{
			cntR=0x00;
			// 			DspRead="Read EEDT OK";
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;				
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
						pProgress->SetPos(LPcnt);
						pProgress->UpdateWindow();
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
					// 					DspRead="Read Error 83.3K";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					// 					DspRead="Read Error EEDT";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_ReadEZSError6;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						// 						DspRead="Read Error EEDT 02";
						// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						//pResult->hidResult=HIDResult_CANErr;
						pResult->hidResult=HIDResult_ReadEZSError6;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	byte wf_EISSSID[4];
	if(mode==0 || mode==3)
	{
		wf_EISSSID[0]=tmpRX[6];
		wf_EISSSID[1]=tmpRX[7];
		wf_EISSSID[2]=tmpRX[9];
		wf_EISSSID[3]=tmpRX[0x0a];
	}
	else
	{
		for(i=0;i<4;i++)
			wf_EISSSID[i]=tmpRX[1+i];
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}

	//------------------
	//第1遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readA[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readA[0x08+i]=outBuf[0xF0+i];
	}
	//------------------
	//----
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip2,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("2"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	int wfWait=5;
	pProgress->SetRange(0,5);   //设置进度条的范围为0-1000	
	pProgress->SetPos(5);
	pProgress->UpdateWindow();
	dwStart=GetTickCount();
	while(wfWait!=0)
	{
		dwCur=GetTickCount();
		dwTime=dwCur-dwStart;
		if(dwTime>1000)
		{
			dwStart=dwCur;
			wfWait--;
			pProgress->SetPos(wfWait);
			pProgress->UpdateWindow();
		}
	}
	//----
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip3,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("3"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//----
	//--------------------
	//重复第2遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			// 			DspRead="Read EEDT OK";
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
						pProgress->SetPos(LPcnt);
						pProgress->UpdateWindow();
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
					// 					DspRead="Read Error 83.3K";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					// 					DspRead="Read Error EEDT";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						// 						DspRead="Read Error EEDT 02";
						// 						SetDlgItemText(IDC_EDIT11, DspRead);
						// 						//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		// 		MessageBox("车载端未激活!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}		
	//------------------
	//第2遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readB[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readB[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<4;i++)
	{
		if(readB[i]!=readA[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		strTemp.LoadString(NULL,IDS_PSWErr);
		strTemp1.LoadString(NULL,IDS_Warring);
		if(MessageBoxEx(hWnd,strTemp, strTemp1,MB_YESNO,CCarKey3App::LANGID) != IDYES)
		{
			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}		
	}
	//------------------
	//----	
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip4,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("4"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	wfWait=5;
	pProgress->SetRange(0,5);   //设置进度条的范围为0-1000	
	pProgress->SetPos(5);
	pProgress->UpdateWindow();
	while(wfWait!=0)
	{
		dwCur=GetTickCount();
		dwTime=dwCur-dwStart;
		if(dwTime>1000)
		{
			dwStart=dwCur;
			wfWait--;
			pProgress->SetPos(wfWait);
			pProgress->UpdateWindow();
		}
	}
	//----
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip5,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("5"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//----	
	//------------------
	//--------------------
	//重复第3遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			// 			DspRead="Read EEDT OK";
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			// 			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
						pProgress->SetPos(LPcnt);
						pProgress->UpdateWindow();
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
					// 					DspRead="Read Error 83.3K";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					// 					DspRead="Read Error EEDT";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						// 						DspRead="Read Error EEDT 02";
						// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}	
	//以上为重复第3遍的模块结尾；		


	//------------------
	//------------------
	//第3遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readC[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readC[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readB[i]!=readC[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		strTemp.LoadString(NULL,IDS_PSWErr,CCarKey3App::LANGID);
		strTemp1.LoadString(NULL,IDS_Warring,CCarKey3App::LANGID);
		if(MessageBoxEx(hWnd,strTemp, strTemp1,MB_YESNO,CCarKey3App::LANGID) != IDYES)
		{

			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}
	}
// 	CPassCalc cpCalc;
// 	for(i=0;i<8;i++)
// 	{
// 		cpCalc.HashIn[i]=readC[0x08+i];
// 	}
// 	cpCalc.sub_HashOnce();	
// 	fSame=true;
// 	for(i=0;i<8;i++)
// 	{
// 		if(readB[0x08+i]!=cpCalc.HashOut[i])
// 		{
// 			fSame=false;
// 		}
// 	}
	CPassCalc cpCalc;
	unsigned int cs;
	bool fCkGO;

	fCkGO=false;
	cs=0x00;
	for(int i=0;i<8;i++)
	{
		cpCalc.HashOut[i]=readC[0x08+i];//为了程序的可读性，提前把数据载入
	}
	while(false==fCkGO)
	{
		for(i=0;i<8;i++)
		{
			cpCalc.HashIn[i]=cpCalc.HashOut[i];//把数据载入到输入内存
		}
		cpCalc.sub_HashOnce();
		fSame=true;
		for(i=0;i<8;i++)
		{
			if(readB[0x08+i]!=cpCalc.HashOut[i])
			{
				fSame=false;	
			}
		}
		if(true==fSame)
		{
			fCkGO=true;//如果相同则退出比较循环
		}
		else
		{
			cs++;
			if(cs>0x04)//假如允许多4步的差异，标准是1步计算后比较一致
			{
				fCkGO=true;
			}
		}
	}



	if(false==fSame)
	{
		strTemp.LoadString(NULL,IDS_PSWErr,CCarKey3App::LANGID);
		strTemp1.LoadString(NULL,IDS_Warring,CCarKey3App::LANGID);
		if(MessageBoxEx(hWnd,strTemp, strTemp1,MB_YESNO,CCarKey3App::LANGID) != IDYES)
		{

			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}
	}
	//------------------
	//----
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip6,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("6"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//----
	byte JiaB[0x06][0x10]={
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x80,0x01},//0
		{0x06,0x26,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0xFF,0x09,0x20,0x01},//1

		//	{0x06,0x38,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x02,0x20,0x00},//2
		{0x06,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x01,0x80,0x01},//2

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00},//3

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00},//4

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01},//5
	};
	byte* IRdt=new byte[0x40*0x400];
	bool fFIN=false;
	unsigned int Ceer=0;
	unsigned int Ctry=0;
	unsigned char Cwait=0;
	//---

	for(i=0;i<0x40*0x400;i++)
	{
		IRdt[i]=0x00;
	}
	P=0x00;
	j=0;//此处也要用线程操作，j值的变化可以做成进度条或闪烁功能
	strTemp.LoadString(IDS_PSWTime);
	strTemp1.Format(strTemp,0,0);
	pStatusBar->SetText(strTemp1,0,0);	
	int minute,second;
	dwStart   =   GetTickCount(); 
	pProgress->SetRange(0,0x400);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	int wfretry=0;
	while(false==fFIN)
	{
		if(*bRun==false)
		{
			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}
		dwCur=   GetTickCount();
		dwTime=dwCur-dwStart;
		dwTime=dwTime/1000;
		minute=dwTime/60;
		second=dwTime%60;
		strTemp.LoadString(IDS_PSWTime);
		strTemp1.Format(strTemp,minute,second);
		pStatusBar->SetText(strTemp1,0,0);

		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=JiaB[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			switch(P)
			{
				//------
			case 0x00:
				if(0x24==rx.buff[0x11])
				{
					for(i=0;i<0x08;i++)
					{
						IRdt[0x40*j+0x00+i]=rx.buff[0x11+i];
					}
					for(i=0;i<0x08;i++)
					{
						JiaB[0x01][0x02+i]=rx.buff[0x11+i];
					}
					for(i=0;i<0x09;i++)
					{
						IRdt[0x40*j+0x10+i]=JiaB[0x01][0x01+i];
					}
					P=0x01;
					byte wf_keySSID[4];
					for(int xx=0;xx<4;xx++)
						wf_keySSID[xx]=rx.buff[0x15+xx];
					bool bSame=true;
					for(int xx=1;xx<4;xx++)
					{
						if(wf_keySSID[xx]!=wf_EISSSID[xx])
						{
							MessageBeep(MB_ICONEXCLAMATION);
							strTemp.LoadString(NULL,IDS_PSWErr2,CCarKey3App::LANGID);
							MessageBoxEx(hWnd,strTemp,_T(""),MB_OK,CCarKey3App::LANGID);
							pResult->hidResult=HIDResult_CANErr;
							return NULL;
						}
					}
				}
				else
				{
					//MessageBox("钥匙读错误1","Read",MB_OK);
					//P=0x03;
					//return;
					Ceer++;
					if(Ceer>0x1800)//0x20
					{
						Ctry++;
						if(Ctry>0x04)
						{
							//MessageBox(_T("重试多次后还是错误"));
							P=0x03;
						}
						else
						{
							P=0x05;//0x04
							Ceer=0x00;
						}
					}
				}
				break;
				//------
			case 0x01:
				if(0x27==rx.buff[0x11])
				{
					for(i=0;i<0x09;i++)
					{
						IRdt[0x40*j+0x20+i]=rx.buff[0x11+i];
					}
					P=0x02;
					Sleep(200);
				}
				else
				{
//					wfretry++;
// 					CString strTemp;
// 					strTemp.Format(_T("b,%d,%d"),wfretry,P);
// 					pStatusBar->SetText(strTemp,0,0);
// 					if(wfretry>400)
// 					{
// 						MessageBox(_T("钥匙读错误2"));
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
// 					}
// 					else
// 					{
// 						P=0;
// 						break;
// 					}
				}
				Ceer=0x00;
				Ctry=0x00;
				j++;
				wfretry=0;
				pProgress->SetPos(j);
				pProgress->UpdateWindow();
				if(*bRun==false)
				{
					pResult->hidResult=HIDResult_UserStop;
					return NULL;
				}
				if(j>=0x400)
				{
					//fFIN=true;
					P=0x03;
				}
				break;
				//------
			case 0x02:
				if(0x24==rx.buff[0x11])
				{
					for(i=0;i<0x08;i++)
					{
						IRdt[0x40*j+0x00+i]=rx.buff[0x11+i];
					}
					for(i=0;i<0x08;i++)
					{
						JiaB[0x01][0x02+i]=rx.buff[0x11+i];
					}
					for(i=0;i<0x09;i++)
					{
						IRdt[0x40*j+0x10+i]=JiaB[0x01][0x01+i];
					}
					P=0x01;
				}
				else
				{
					Ceer++;
					if(Ceer>60)
					{
						//MessageBox(_T("钥匙读错误1"));
						P=0x00;
						//P=0x05;//0x00
					}
				}
				break;
				//------
			case 0x03:
				fFIN=true;
				break;
				//------
			case 0x04:
				P=0x00;//备用数据组，意为从00组重新开始，此处可以添加计数单元到一定次数后再把P设为00，
				//	fFIN=true;
				break;
				//------
				//------
			case 0x05:
				if(0x24==rx.buff[0x11])
				{
					P=0x03;
				}
				else
				{

				}
				break;
				//------				
			default:
				//MessageBox("未知错误1!","Error",MB_OK);
				pResult->hidResult=HIDResult_CANErr;
				return NULL;
			}
		}
		else
		{
//  			wfretry++;
//  			CString strTemp;
//  			strTemp.Format(_T("a,%d,%d"),wfretry,P);
//  			pStatusBar->SetText(strTemp,0,0);
//  			if(wfretry>400)
//  			{
				switch(P)
				{
					//------
				case 0x00:
				case 0x02:
// 					//MessageBox(_T("没检测到钥匙!!"),_T("Read"),MB_OK);
					P=0x04;//意思为跳出到退出数据组03，可以让P为04，关闭感应电源，
					TRACE(_T("02or00\r\n"));
					wfretry++;
					if(wfretry>5)
					{						
						MessageBeep(MB_ICONEXCLAMATION);
						strTemp.LoadString(NULL,IDS_PSWErr1,CCarKey3App::LANGID);
						strTemp1.LoadString(NULL,IDS_Warring,CCarKey3App::LANGID);
						if(MessageBoxEx(hWnd,strTemp, strTemp1,MB_OKCANCEL,CCarKey3App::LANGID) != IDOK)
						{

							pResult->hidResult=HIDResult_UserStop;
							return NULL;
						}
						wfretry=0;
						//MessageBox(_T("没检测到钥匙!!"),_T("Read"),MB_OK);
					}
					//return;
					break;
					//------
				case 0x01:
					//MessageBox("接收错误!!","Read",MB_OK);
 					P=0x04;
					TRACE(_T("01\r\n"));
					//return;
					break;
					//------
					//------
				case 0x05:
					Cwait++;
					if(Cwait>0x03)
					{
						Cwait=0;
						P=0x00;
					}
					break;
					//------
					//------
				default:
					//MessageBox(_T("未知错误2!"));
					pResult->hidResult=HIDResult_CANErr;
					return NULL;		
				}
			//}
// 			else
// 				P=0;
		}
	}
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip8,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("7"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	wfWait=30;
	pProgress->SetRange(0,30);   //设置进度条的范围为0-1000	
	pProgress->SetPos(30);
	pProgress->UpdateWindow();
	while(wfWait!=0)
	{
		dwCur=GetTickCount();
		dwTime=dwCur-dwStart;
		if(dwTime>1000)
		{
			dwStart=dwCur;
			wfWait--;
			pProgress->SetPos(wfWait);
			pProgress->UpdateWindow();
		}
	}
	//----	
	//------------------
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip9,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("8"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}	
	//----	
	//--------------------
	//重复第4遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			// 			DspRead="Read EEDT OK";
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
						pProgress->SetPos(LPcnt);
						pProgress->UpdateWindow();
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
					// 					DspRead="Read Error 83.3K";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					// 					DspRead="Read Error EEDT";
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						// 						DspRead="Read Error EEDT 02";
						// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	//------------------
	//第4遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readD[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readD[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readD[i]!=readC[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("车载端读取异常!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//
	//CPassCalc cpCalc;
	for(i=0;i<8;i++)
	{
		//HashIn[i]=readD[0x08+i];
		cpCalc.HashOut[i]=readD[0x08+i];
	}
	//sub_HashOnce();
	//
// 	for(j=0;j<0x400;j++)
// 	{
// 		for(i=0;i<8;i++)
// 		{
// 			cpCalc.HashIn[i]=cpCalc.HashOut[i];
// 		}
// 		cpCalc.sub_HashOnce();
// 		for(i=0;i<8;i++)
// 		{
// 			IRdt[0x40*(0x3FF-j)+0x30+i]=cpCalc.HashOut[i];
// 		}
// 	}
// 	//
// 	for(i=0;i<8;i++)
// 	{
// 		cpCalc.HashIn[i]=cpCalc.HashOut[i];
// 	}
// 	cpCalc.sub_HashOnce();
// 	fSame=true;
// 	for(i=0;i<8;i++)
// 	{
// 		if(readC[0x08+i]!=cpCalc.HashOut[i])
// 		{
// 			fSame=false;
// 		}
// 	}
	
	unsigned char Th[0x08*0x408];
	for(j=0;j<0x400;j++)//先算400h组数据后再进行下面的比较
	{
		for(i=0;i<8;i++)
		{
			cpCalc.HashIn[i]=cpCalc.HashOut[i];
		}
		cpCalc.sub_HashOnce();
		for(i=0;i<8;i++)
		{
			Th[j*0x08+i] = cpCalc.HashOut[i];
		}
	}
	//
	fCkGO=false;
	cs=0x400;//意为比较过程中的存储位置是从400H开始的
	//HashOut引入的初始值值是上面算的第03FFh个数据，
	while(false==fCkGO)
	{
		for(i=0;i<8;i++)
		{
			cpCalc.HashIn[i]=cpCalc.HashOut[i];//把数据载入到输入内存
		}
		cpCalc.sub_HashOnce();
		for(i=0;i<8;i++)
		{
			Th[cs*0x08+i] = cpCalc.HashOut[i];//比较前载入暂存数组，
		}
		fSame=true;
		for(i=0;i<8;i++)
		{
			if(readC[0x08+i]!=cpCalc.HashOut[i])
			{
				fSame=false;	
			}
		}
		if(true==fSame)
		{
			fCkGO=true;//如果相同则退出比较循环
		}
		else
		{
			cs++;
			if(cs>0x404)//假如允许多4步的差异，标准是1步计算后比较一致
			{
				fCkGO=true;
			}
		}
	}
	if(true==fSame)
	{
		cs=cs-0x400;//指向第一个适配的行标
		for(j=0;j<0x400;j++)
		{
			for(i=0;i<8;i++)
			{
				IRdt[0x40*(0x3FF-j)+0x30+i]=Th[cs*0x08+i];
			}
			cs++;
		}
	}
	if(false==fSame)
	{
		//MessageBox("采集数据异常!!","Error",MB_OK);
		//return;
		strTemp.LoadString(NULL,IDS_PSWTip11,CCarKey3App::LANGID);
		strTemp1.LoadString(NULL,IDS_Warring,CCarKey3App::LANGID);
		if(MessageBoxEx(hWnd,strTemp, strTemp1,MB_YESNO,CCarKey3App::LANGID) != IDYES)
		{

			pResult->hidResult=HIDResult_CANErr;
			return NULL;
		}
 		
	}
	// 	//------------------
	// 	CFileDialog fileDlgS(FALSE);
	// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
	// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
	// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
	// 	if (IDOK==fileDlgS.DoModal())
	// 	{
	// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
	// 		file.Write(IRdt,0x40*0x400);
	// 		file.Close();
	// 	}
	// 	//------------------
	return IRdt;
	VMProtectEnd();
}
byte* CHIDWork::QuanDiu02(HWND hWnd,int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,bool* bRun)
{
	VMProtectBegin("HIDWork_QuanDiu02");
	// TODO: Add your control notification handler code here
	int i;
	CString str;	
	//------------
	const byte CAN_dtA[0x10]={0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//500k
	//const char CAN_dtB[0x10]={0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//83.3k
	bool fDut=false;//波特率重试标识；每次点下按钮，仅重试1次后。

	const byte RDcmd[0x0A]={0x00,0x01,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E};

	//第1款--无错误动态字发生
	const byte CANm_A[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANm_B[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANm_C[0x06][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANm_D[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANm_E[0x07][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANm_G[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANm_H[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//
	byte RDdiu[0x08][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00 // 15--uart initial
		{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00},//01 // 15--ON Vdd delay

		{0x03,0x25,0x7D,0x1E,0x2F,0xCB,0x00,0x00,0x8F,0x00,0x00,0x00,0x00,0x08,0x30,0x01},//02 // 14--ir tx and rx
		{0x03,0x27,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x00,0x09,0x00,0x00},//03 // 14--ir tx and no rx
		{0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x40,0x0C},//04 // 15--uart rx

		{0x01,0x55,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x0B,0x40,0x00},//05 //

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//06 // 15--OFF Vdd delay--倒数第二个位置现在是0X80，是调整掉电时间的

		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00},//07 // 15--OFF Vdd delay
	};
	const unsigned char RDd0[0x08]={0x15,0x15,0x14,0x14,0x15,0x15,0x15,0x15};
	const unsigned char RDd1[0x08]={0x47,0x80,0x22,0x71,0x85,0x87,0x2F,0x9B};
	unsigned char RDd2[0x08]={0x00,0x00,0x00,0x00,0x7D,0x00,0x00,0x25};
	unsigned char tptx[0x20],tprx[0x20];
	//
	byte tmpRX[0x800];
	int m;
	int j;
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;
	unsigned char cnt1=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Td[0x10]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;//每次加1的送数
	unsigned char k;
	

	unsigned char rdEEDT[0x09][0x06]={
		{0x0A,0x06,0x08,0x1A,0x00,0x00},//1--无错误
		{0x07,0x03,0x05,0x1C,0x00,0x00},//2--无错误
		{0x06,0x03,0x04,0x1C,0x01,0x03},//3--
		{0x07,0x03,0x05,0x1A,0x00,0x00},//4--无错误
		{0x07,0x03,0x05,0x1C,0x01,0x04},//5--
		{0x06,0x03,0x04,0x1C,0x01,0x03},//6--
		{0x07,0x03,0x05,0x1C,0x01,0x04},//7
		{0x07,0x03,0x05,0x1C,0x01,0x04},//8
		{0x07,0x03,0x05,0x1C,0x01,0x04},//9
	};
	unsigned char rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

		/*
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1--无错误
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//2--无错误
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//3--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//4--无错误
		{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//5--10,0E,71,01,00,22,70,01
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//6--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//7
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//8
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//9
	};*/

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];//加入动态命令字的位置
	JC = rdEEDT[mode][0x05];//需要检查的行标

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	const char TS[0x09][0x04]={
		{0x06,0x02,0x09,0x06},//1--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//3--
		{0x06,0x02,0x09,0x06},//4--
		{0x01,0x07,0x09,0x01},//5--
		{0x01,0x07,0x09,0x01},//6--
		{0x01,0x07,0x09,0x01},//7--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];
	//
	bool fSame=false;
	//unsigned char readA[0x10],readB[0x10],readC[0x10],readD[0x10];
	unsigned char outBuf[0x800];
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		return NULL;
	}
	
	//-----------------------------------------
	//-----------------------------------------
	//-----------------------------------------
// 	Td[0]=0x14;
// 	Td[1]=0x55;
// 	Td[2]=0x00;
// 	Td[3]=0x00;
// 	Td[4]=0x20;	//本次传送数据的长度；
// 	Td[5]=0x00;
// 	Td[6]=0x00;
// 	Td[7]=0x00;
// 	Td[8]=SwVer[1];//L
// 	Td[9]=SwVer[0];//H	
	CString strTemp,strTemp1;
	CInteractionData tx;
	CInteractionData rx;
	tx.Init();
	tx.buff[0] = 0x15;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
	const byte ctPON[0x10]=
			{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};// 15--ON Vdd delay
	for(i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=ctPON[i];
		tptx[i]=ctPON[i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		pResult->hidResult= HIDResult_USBError;
		return NULL;
	}
	else if (rx.CheckDataList() == false)
	{
		pResult->hidResult= HIDResult_RxError;
		return NULL;
	}
	else if (rx.buff[1] == 0x00)
	{
		// 			
	}
	//--------------------
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip16,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("1"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//--------------------
// 	str="请把OBD线连接到车载端";
// 	if(MessageBox(str, "提示1",MB_YESNO) == IDYES)
// 	{
// 		//MessageBox("GOON!!","YES",MB_OK);
// 	}
// 	else
// 	{
// 		return;
// 	}
	//--------------------
	//以下程序上面的按钮程序写了4遍，如果你做成模块，可以直接调用
	//
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;	
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用		//
		
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			// 			
		}
		//--
		if(0x00==rx.buff[1])
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	//------------------
	//此块是测试保存用途，正式开发时候去掉
/*	CFileDialog fileDlgS(FALSE);
	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
	fileDlgS.m_ofn.lpstrDefExt="BIN";
	if (IDOK==fileDlgS.DoModal())
	{
		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
		file.Write(outBuf,0x400);
		file.Close();
	}*/
	//delete []outBuf;
	//outBuf=NULL;
	//------------------
	//以上为重复4遍的模块结尾；

	
	//------------------
	//第1遍读车载端结束取数
	for(i=0;i<4;i++)
	{
	//	RDdiu[0x00][0x03+i]=outBuf[i];
		RDdiu[0x02][0x05+i]=outBuf[i];//此处载入的是遥控ID部分，第一次载入的数据或运算 |01,就是01编号钥匙
	}
	RDdiu[0x02][0x05]=RDdiu[0x02][0x05]|0x03;
	tx.Init();
	tx.buff[0] = 0x15;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
	const byte ctPOFF[0x10]=
			{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00}; // 15--OFF Vdd delay
	for(i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=ctPOFF[i];
		tptx[i]=ctPOFF[i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		pResult->hidResult= HIDResult_USBError;
		return NULL;
	}
	else if (rx.CheckDataList() == false)
	{
		pResult->hidResult= HIDResult_RxError;
		return NULL;
	}
	else if (rx.buff[1] == 0x00)
	{
		// 			
	}
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//------------------
	//----
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip17,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("2"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
// 	str="点确定后请及时把红外适配器插入钥匙孔";
// 	if(MessageBox(str, "提示2",MB_YESNO) == IDYES)
// 	{
// 		//MessageBox("GOON!!","YES",MB_OK);
// 	}
// 	else
// 	{
// 		return;
// 	}
	//------------------
//	char RDdiu[0x08][0x10]={
//		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00 // 15--uart initial
//		{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00},//01 // 15--ON Vdd delay
//
//		{0x03,0x25,0x7D,0x1E,0x2F,0xCB,0x00,0x00,0x8F,0x00,0x00,0x00,0x00,0x08,0x30,0x01},//02 // 14--ir tx and rx
//		{0x03,0x27,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x00,0x09,0x00,0x00},//03 // 14--ir tx and no rx
//		{0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x40,0x0A},//04 // 15--uart rx
//
//		{0x01,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x00,0x0B,0xF0,0x00},//05 // 后面的55位置的值应该是前面55开始的10个数的和，此处要做个预处理
//
//		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00},//06 // 15--OFF Vdd delay
//
//		{0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00},//07 // 15--OFF Vdd delay
//
//	};
	//
	byte* IRdt=new byte[0x80*0x400];
	bool fFIN=false;
	bool fOK=false;
	unsigned int Ceer=0;
	unsigned int Ctry=0;
	unsigned char Cwait=0;
	bool fON=false;//等待红外头插入标识
	//---
	for(i=0;i<0x80*0x400;i++)
	{
		IRdt[i]=0x00;
	}
	P=0x00;
	bool fAdd=true;//默认递增

	j=0;
	strTemp.LoadString(NULL,IDS_PSWTime,CCarKey3App::LANGID);
	strTemp1.Format(strTemp,0,0);
	pStatusBar->SetText(strTemp1,0,0);
	DWORD     dwStart,dwCur,dwTime;	
	int minute,second;
	dwStart   =   GetTickCount(); 
	pProgress->SetRange(0,0x400);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	byte RdDiufix=0x7d;
	byte rxTenp[4][0x10];
	byte oldKey[0x10];
	for(int xx=0;xx<0x10;xx++)
	{
		oldKey[xx]=0;
	}
	//int wfretry;
	while(false==fFIN)
	{
		if(*bRun==false)
		{
			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}
		dwCur=   GetTickCount();
		dwTime=dwCur-dwStart;
		dwTime=dwTime/1000;
		minute=dwTime/60;
		second=dwTime%60;
		strTemp.LoadString(NULL,IDS_PSWTime,CCarKey3App::LANGID);
		strTemp1.Format(strTemp,minute,second);
		pStatusBar->SetText(strTemp1,0,0);
// 		if(P==2)
// 		{
// 			if(RdDiufix==0)
// 				RdDiufix=0x7f;
// 			else
// 				RdDiufix--;
// 			RDdiu[0x02][0x02]=RdDiufix;
// 		}
		tx.Init();
		tx.buff[0] = RDd0[P];
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		//Td[0]=RDd0[P];		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RDdiu[P][i];			
			tptx[i]=RDdiu[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		}
		for(i=0;i<0x10;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}		
		//--
		CPassCalc cp;
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
				case 0x00://uart initial
				case 0x01://ON Vdd delay
				case 0x05://uart tx only
				case 0x06://OFF Vdd delay
					break;
				//------
				case 0x02:
					Ctry=0;
					if(0x26==tprx[0x01])
					{
						for(i=0;i<0x08;i++)
						{
							rxTenp[0][i]=tptx[i+0x01];
							//IRdt[0x40*j+0x00+i]=tptx[i+0x01];
						}
						for(i=0;i<0x09;i++)
						{
							rxTenp[1][i]=tprx[i+0x01];
							//IRdt[0x40*j+0x10+i]=tprx[i+0x01];
						}
					}
					else
					{
						//MessageBox("红外回复错误!!","Read",MB_OK);
					}					
					//--
					for(i=0;i<8;i++)
					{
						cp.HashIn[i]=tprx[i+0x01];
					}
					cp.sub_HashOnce();

					RDd2[4]=tptx[0x02];
					RDd2[5]=tptx[0x03];
					RDd2[6]=tptx[0x04];
					RDd2[7]=tptx[0x01];

					for(i=0;i<0x08;i++)
					{
						RDdiu[0x03][0x02+i]=cp.HashOut[i]^RDd1[i]^RDd2[i];
					}
					//--
				//	fON=true;
					break;
				//------
				case 0x03:
					for(i=0;i<0x09;i++)
					{
						rxTenp[2][i]=tptx[i+0x01];
						//IRdt[0x40*j+0x20+i]=tptx[i+0x01];
					}
					break;
				//------
				case 0x04:
					Ctry=0;
					for(i=0;i<0x08;i++)
					{
						rxTenp[3][i]=tprx[i+0x04];
						//IRdt[0x40*j+0x30+i]=tprx[i+0x04];
					}
					break;
				//------
				case 0x07:
					fAdd=false;//不递增
					fFIN=true;
				//	fOK=false;
					break;
				//------
				default:
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				//MessageBox("未知错误1!","Error",MB_OK);
				//return;
			}
			//
			if(true==fAdd)//递增
			{
				P++;
				if(P>=0x07)
				{
					P=0x00;
					bool bSame=true;
					for(int xx=0;xx<8;xx++)
					{
						if(oldKey[xx]!=rxTenp[3][xx])
						{
							bSame=false;
							break;
						}
					}
					if(!bSame)
					{
						for(int xx=0;xx<8;xx++)
						{
							oldKey[xx]=rxTenp[3][xx];
						}
						for(int xi=0;xi<8;xi++)
						{
							IRdt[0x40*j+0x00+xi]=rxTenp[0][xi];
						}
						for(int xi=0;xi<9;xi++)
						{
							IRdt[0x40*j+0x10+xi]=rxTenp[1][xi];
						}
						for(int xi=0;xi<9;xi++)
						{
							IRdt[0x40*j+0x20+xi]=rxTenp[2][xi];
						}
						for(int xi=0;xi<8;xi++)
						{
							IRdt[0x40*j+0x30+xi]=rxTenp[3][xi];
						}
						j++;
						pProgress->SetPos(j);
						pProgress->UpdateWindow();
						if(*bRun==false)
						{
							pResult->hidResult=HIDResult_UserStop;
							return NULL;
						}
						if(j>=0x400)//0x400
						{
							fFIN=true;
							fOK=true;
						}
					}
				}
			}
		}
		else
		{
			switch(P)
			{
				//------
				case 0x00://uart initial
				case 0x01://ON Vdd delay
				case 0x05://uart tx only
				case 0x06://OFF Vdd delay
				case 0x07://OFF Vdd delay
// 					MessageBox("异常错误1!","Error",MB_OK);
// 					return;	
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
					//break;
				//------
				case 0x02:
				//	fAdd=false;//不递增
				//	Ctry++;
				//	if(Ctry>0x08)
					{
						MessageBoxEx(hWnd,_T("红外接收超时2!!"), _T("err02"),MB_OK,CCarKey3App::LANGID);
						//MessageBox("红外接收超时2!!","Read",MB_OK);
						fAdd=false;//不递增
						P=0x07;
					}

					break;
				//--------
				case 0x03:
					//MessageBox("红外接收超时3!!","Read",MB_OK);
					MessageBoxEx(hWnd,_T("红外接收超时3!!"), _T("err03"),MB_OK,CCarKey3App::LANGID);
					fAdd=false;//不递增
					P=0x07;
					//return;
					break;
				//------
				case 0x04:
					for(i=0;i<0x0C;i++)
					{
						IRdt[0x40*j+0x30+i]=tprx[i+0x01];
					}
					fAdd=false;//不递增
					Ctry++;
					P=0x00;//新添加，意思是指向重试的开始发射包
					if(Ctry>0x10)
					{
						//MessageBox("UART接收超时4!!","Read",MB_OK);
						MessageBoxEx(hWnd,_T("UART接收超时4!!"), _T("err04"),MB_OK,CCarKey3App::LANGID);
						fAdd=false;//不递增
						P=0x07;
					}
					//return;
					break;
				//------
				//------
				default:
					//MessageBox("异常错误2!","Error",MB_OK);
					return NULL;			
			}
		}

	}
	return IRdt;
// 	此块是测试保存用途，正式开发时候去掉
// 		CFileDialog fileDlgS(FALSE);
// 		fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 		fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 		fileDlgS.m_ofn.lpstrDefExt="BIN";
// 		if (IDOK==fileDlgS.DoModal())
// 		{
// 			CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 			file.Write(IRdt,0x40*0x800);//0x40*0x400
// 			file.Close();
// 		}
	VMProtectEnd();
}
byte* CHIDWork::QuanDiu03(HWND hWnd,int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,bool* bRun)
{
	VMProtectBegin("HIDWork12");
	// TODO: Add your control notification handler code here
	int i;
	CString str;//="都是进口垃圾地方";
	//------------
	const byte CAN_dtA[0x10]={0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//500k
	//const char CAN_dtB[0x10]={0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//83.3k
	bool fDut=false;//波特率重试标识；每次点下按钮，仅重试1次后。

	const byte RDcmd[0x0A]={0x00,0x01,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E};

	//第1款--无错误动态字发生
	const byte CANm_A[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANm_B[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANm_C[0x06][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANm_D[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANm_E[0x07][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANm_G[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANm_H[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//
	byte RDdiu[0x08][0x10]={                                        //高        低 0x30*10=480ms
		{0x03,0x50,0x00,0x00,0x00,0x00,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x50,0x01},
		{0x03,0x53,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x00,0x09,0xff,0x01},
		{0x03,0x05,0x00,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x00,0x00,0x0A,0xff,0x01},
		{0x03,0x05,0x01,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x00,0x00,0x0A,0xff,0x01},
	//	{0x03,0x05,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x00,0x01},
	};

	//
	byte tmpRX[0x800];
	int m;
	int j;
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;
	unsigned char cnt1=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Td[0x10]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x0A,0x06,0x08,0x1A,0x00,0x00},//1--无错误
		{0x07,0x03,0x05,0x1C,0x00,0x00},//2--无错误
		{0x06,0x03,0x04,0x1C,0x01,0x03},//3--
		{0x07,0x03,0x05,0x1A,0x00,0x00},//4--无错误
		{0x07,0x03,0x05,0x1C,0x01,0x04},//5--
		{0x06,0x03,0x04,0x1C,0x01,0x03},//6--
		{0x07,0x03,0x05,0x1C,0x01,0x04},//7
		{0x07,0x03,0x05,0x1C,0x01,0x04},//8
		{0x07,0x03,0x05,0x1C,0x01,0x04},//9
	};
	unsigned char rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

		/*
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1--无错误
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//2--无错误
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//3--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//4--无错误
		{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//5--10,0E,71,01,00,22,70,01
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//6--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//7
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//8
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//9
	};*/

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];//加入动态命令字的位置
	JC = rdEEDT[mode][0x05];//需要检查的行标

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	const byte TS[0x09][0x04]={
		{0x06,0x02,0x09,0x06},//1--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//3--
		{0x06,0x02,0x09,0x06},//4--
		{0x01,0x07,0x09,0x01},//5--
		{0x01,0x07,0x09,0x01},//6--
		{0x01,0x07,0x09,0x01},//7--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];
	//
	bool fSame=false;
	//unsigned char readA[0x10],readB[0x10],readC[0x10],readD[0x10];
	unsigned char outBuf[0x800];
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}	
	CString strTemp,strTemp1;
	//--------------------
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	MessageBeep(MB_ICONEXCLAMATION);
	strTemp.LoadString(NULL,IDS_PSWTip13,CCarKey3App::LANGID);
	strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("1"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	{

		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//--------------------
	//以下程序上面的按钮程序写了4遍，如果你做成模块，可以直接调用
	//
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,8);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
					pProgress->SetPos(LPcnt);
					pProgress->UpdateWindow();
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
						pProgress->SetPos(LPcnt);
						pProgress->UpdateWindow();
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					//pResult->hidResult= HIDResult_CANErr;
					pResult->hidResult=HIDResult_ReadEZSError6;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						//pResult->hidResult= HIDResult_CANErr;
						pResult->hidResult=HIDResult_ReadEZSError6;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox(_T("车载端未激活!!"),_T("Error"),MB_OK);
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	//------------------
	//此块是测试保存用途，正式开发时候去掉
/*	CFileDialog fileDlgS(FALSE);
	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
	fileDlgS.m_ofn.lpstrDefExt="BIN";
	if (IDOK==fileDlgS.DoModal())
	{
		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
		file.Write(outBuf,0x400);
		file.Close();
	}*/
	//delete []outBuf;
	//outBuf=NULL;
	//------------------
	//以上为重复4遍的模块结尾；

	
	//------------------
	//第1遍读车载端结束取数
	for(i=0;i<4;i++)
	{
		RDdiu[0x00][0x03+i]=outBuf[i];
	}
	//------------------
	//----
	if(*bRun==false)
	{
		pResult->hidResult=HIDResult_UserStop;
		return NULL;
	}
	//MessageBeep(MB_ICONEXCLAMATION);
	//strTemp.LoadString(NULL,IDS_PSWTip10,CCarKey3App::LANGID);
	//strTemp1.LoadString(NULL,IDS_PSWStep,CCarKey3App::LANGID);
	//if(MessageBoxEx(hWnd,strTemp, strTemp1+_T("2"),MB_YESNO,CCarKey3App::LANGID) != IDYES)
	//{

	//	pResult->hidResult=HIDResult_UserStop;
	//	return NULL;
	//}

 	tx.Init();
 	tx.buff[0] = 0x14;
 	tx.buff[1] = 0x55;	//主机-->设备 
 	tx.buff[4]=0x20;
 	for(i=0;i<0x10;i++)
 	{
 		tx.buff[i+0x10]=CANm_H[6][i];
 	}
 	rx = DeviceInteraction(tx);
 	if (!rx.bOK)
 	{
 		pResult->hidResult= HIDResult_USBError;
 		return NULL;
 	}
 	else if (rx.CheckDataList() == false)
 	{
 		pResult->hidResult= HIDResult_RxError;
 		return NULL;
 	}
 	else if (rx.buff[1] != 0x00)
 	{
 		pResult->hidResult= HIDResult_RxError;
 		return NULL;
 	}
	//------------------
//	char RDdiu[0x08][0x10]={
//		{0x03,0x50,0x00,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x01},
//		{0x03,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0x20,0x01},
//		{0x03,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//		{0x03,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//		{0x03,0x05,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//	};
	//
	byte* IRdt=new byte[0x80*0x400];
	bool fFIN=false;
	unsigned int Ceer=0;
	unsigned int Ctry=0;
	unsigned char Cwait=0;
	bool fON=false;//等待红外头插入标识
	//---
	for(i=0;i<0x80*0x400;i++)
	{
		IRdt[i]=0x00;
	}
	P=0x00;
	j=0;
	strTemp.LoadString(NULL,IDS_PSWTime,CCarKey3App::LANGID);
	strTemp1.Format(strTemp,0,0);
	pStatusBar->SetText(strTemp1,0,0);
	DWORD     dwStart,dwCur,dwTime;	
	int minute,second;
	dwStart   =   GetTickCount(); 
	pProgress->SetRange(0,0x400);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	int retry=10;
	while(false==fFIN)
	{
		if(*bRun==false)
		{
			pResult->hidResult=HIDResult_UserStop;
			return NULL;
		}
		dwCur=   GetTickCount();
		dwTime=dwCur-dwStart;
		dwTime=dwTime/1000;
		minute=dwTime/60;
		second=dwTime%60;
		strTemp.LoadString(NULL,IDS_PSWTime,CCarKey3App::LANGID);
		strTemp1.Format(strTemp,minute,second);
		pStatusBar->SetText(strTemp1,0,0);
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RDdiu[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			switch(P)
			{
				//------
				case 0x00:
					if(0x63==rx.buff[0x11])
					{
						for(i=0;i<0x09;i++)
						{
							IRdt[0x80*j+0x20*P+0x10+i]=rx.buff[0x11+i];
						}
					}
					else
					{						//
						retry--;
						if(retry==0)
						{
							pResult->hidResult=HIDResult_CANErr;
						}
						TRACE("2\r\n");
						j=0;
						P=0;
					}
					fON=true;
					break;
				//------
				case 0x01:
				case 0x02:
				case 0x03:
			//	case 0x04:
					if(0x68==rx.buff[0x11])
					{
						for(i=0;i<0x0A;i++)
						{
							IRdt[0x80*j+0x20*P+0x10+i]=rx.buff[0x11+i];
						}
					}
					else
					{
						retry--;
						if(retry==0)
						{
							pResult->hidResult=HIDResult_CANErr;
							return NULL;
						}
						TRACE("3\r\n");
						j=0;
						P=0;
					}
					break;
				//------
				default:
					//MessageBox("未知错误1!","Error",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
			}
			//
			for(i=0;i<0x0A;i++)
			{
				IRdt[0x80*j+0x20*P+i]=RDdiu[P][i+0x01];
			}
			//
			P++;
			if(P>=0x04)
			{
				P=0x00;
				j++;
				pProgress->SetPos(j);
				pProgress->UpdateWindow();
				if(*bRun==false)
				{
					pResult->hidResult=HIDResult_UserStop;
					return NULL;
				}
				if(j>=0x400)//0x01
				{
					fFIN=true;
				}
				Sleep(30);
			}
		}
		else
		{
			switch(P)
			{
				//------
				case 0x00:
					if(false==fON)
					{
						Ctry++;
						if(Ctry>0x100)
						{
							//MessageBox("红外适配器插入 超时!!","Read",MB_OK);
							pResult->hidResult= HIDResult_CANErr;
							return NULL;
						}
					}
					else
					{
						//MessageBox("接收超时!!","Read",MB_OK);
						retry--;
						if(retry==0)
						{
							pResult->hidResult=HIDResult_CANErr;
							fFIN=true;
						}
						else
						{
							TRACE("0\r\n");
							j=0;
							P=0;
						}
//  						pResult->hidResult=HIDResult_CANErr;
//  						
					}
					break;
				//--------
				case 0x01:
				case 0x02:
				case 0x03:
			//	case 0x04:
					//MessageBox("接收超时!!","Read",MB_OK);
					retry--;
					if(retry==0)
					{
						pResult->hidResult=HIDResult_CANErr;
						fFIN=true;
					}
					else
					{
						TRACE("1\r\n");
						j=0;
						P=0;
					}
 					//pResult->hidResult=HIDResult_CANErr;
 					//fFIN=true;
					//return;
					break;
				//------
				//------
				default:
					//MessageBox("未知错误2!","Error",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;			
			}
		}

	}
// 	str.Format(_T("发生错误次数:%d"),10-retry);
// 	pStatusBar->SetText(str,0,0);
	//此块是测试保存用途，正式开发时候去掉
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(IRdt,0x80*0x400);//0x40*0x400
// 		file.Close();
// 	}
	return IRdt;
	VMProtectEnd();
	//------------------
}

byte* CHIDWork::EISTest( int mode,CInteractionData* pResult ,int* pIndex)
{
	VMProtectBegin("HIDWork13");
	int i,j;

	//第1款--
	const byte CANee_A[0x10][0x10]={
		//{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		//{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x1A,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x03},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//循环开始
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x1A,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//循环结束--空延时

//		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
//		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

//		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
//		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x05,0x6F,0x26,0xFF,0xFF,0xFF,0x00,0x01},
//		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--
	const byte CANee_B[0x0E][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//05--循环开始
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x01},//0B--检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//0C--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANee_C[0x0E][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//05--循环开始
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x01},//0B--检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//0C--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--
	const byte CANee_D[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//05--循环开始
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x1A,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x21,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//07--检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//08--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};
	//第5款
	const byte CANee_E[0x0F][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//05--循环开始
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x01},//0C--检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//0D--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0E
	};
	//第7款
	const byte CANee_G[0x0F][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//05--循环开始
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x01},//0B--检测组
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x02,0x00,0x10,0x00,0x00,0x00,0x00,0x01},//
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//0D--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0E
	};
	//第8款//第9款
	const byte CANee_H[0x0F][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//05--循环开始
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x02},//0C--检测组
		{0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00},//0D--循环结束--空延时

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0E
	};
	unsigned char Rx;
	unsigned char cntR=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,JC,STP;
//	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x10,0x0B,0x0E,0x0D,0x0F,0x00},//1----
		{0x0E,0x05,0x0C,0x0B,0x0D,0x00},//2----
		{0x0E,0x05,0x0C,0x0B,0x0D,0x00},//3----
		{0x0A,0x05,0x08,0x07,0x09,0x00},//4----
		{0x0F,0x05,0x0D,0x0C,0x0E,0x00},//5----
		{0x0E,0x05,0x0C,0x0B,0x0D,0x00},//6----
		{0x0F,0x05,0x0D,0x0B,0x0E,0x00},//7----
		{0x0F,0x05,0x0D,0x0C,0x0E,0x00},//8----
		{0x0F,0x05,0x0D,0x0C,0x0E,0x00},//9----
	};
	unsigned char rdCK[0x08]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	JC = rdEEDT[mode][0x03];//需要检查的行标
	STP =  rdEEDT[mode][0x04];
//	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;

	bool fAdd=false;//无需递增
	//	r=mode;
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	byte* pBuf=new byte[16];
	for(i=0;i<0x10;i++)
	{
		pBuf[i]=0x00;
	}
	CInteractionData tx;
	CInteractionData rx;
	bool fSTP=false;//因为不会用按钮停止，所以以计数到停止
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[(*pIndex)][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		fAdd=true;//默认递增
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if(0x00==rx.buff[1])
		{
			cntR=0x00;
// 			DspRead="EKTEST GO";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			fSAV=false;
			//
			if(0x01==(*pIndex))
			{
				(*pIndex)+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
				fAdd=false;//无需递增
			}
			//
			if(JC==(*pIndex))//需要检查的行，目前为检测到有变化就记录，后续开发改为根据收到的数据判断进度显示。
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(mode<0x07)//00--06,也就是01款到07款
					{
						if(rdCK[i]!=rx.buff[i+0x10])//BufInput[i+0x10]),i从0到7，8字节为收到的数据；
						{
							fRS=false;
						}
					}
					else// >=07,也就是08,09款的时候比较第二包数据
					{
						if(rdCK[i]!=rx.buff[i+0x10+0x08])//BufInput[i+0x10]),i从0到7，8字节为收到的数据；
						{
							fRS=false;
						}
					}
				}
				if(false==fRS)//检测到有变化,打开记录标识，后续开发可删除
				{
					fSAV=true;//检查正确，保存
					for(i=0;i<0x08;i++)
					{
						if(mode<0x07)//00--06,也就是01款到07款
						{
							rdCK[i]=rx.buff[i+0x10];//更新比较暂存，不一样保存，且更新，后续开发可删除，因为是后续是靠判断接收的字节的某位来指示的。
						}
						else // >=07,也就是08,09款的时候用第二包数据
						{
							rdCK[i]=rx.buff[i+0x10+0x08];
						}
					}
				}
			}
			//
			if((*pIndex)==STP)
			{
				fSTP=true;//发送过停止CAN命令后停止检测
				fAdd=false;//无需递增
			}
			//---
		}
		else
		{
			if(0x01==(*pIndex))
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				//此处为第一种波特率失败的情况，默认递增，所以注释掉，这样就进入了第二种波特率的数据发射
				//P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					pResult->hidResult=HIDResult_ReadEZSError6;
					//pResult->hidResult= HIDResult_CANErr;
					return NULL;
					//MessageBox("Read Error","Read",MB_OK);					
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						pResult->hidResult=HIDResult_ReadEZSError6;
						//pResult->hidResult= HIDResult_CANErr;
						return NULL;
						//MessageBox("Read Error","Read",MB_OK);
					}
					else
					{
						fAdd=false;//无需递增,握手包，没握手成功不递增
					}
				}
			}
		}
		//--
		if(true==fAdd)
		{
			(*pIndex)++;
			if((*pIndex)>LPend)
			{
				(*pIndex)=LPstart;
			}
		}
		//------------------
		if(true==fSAV)//存储收到的状态数据，后续开发可删除
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					if(mode<0x07)//00--06,也就是01款到07款
					{
						pBuf[i]=rx.buff[i+0x10];
					}
					else // >=07,也就是08,09款的时候用第二包数据
					{
						pBuf[i]=rx.buff[i+0x10+0x08];
					}
				}
				return pBuf;
			}
		}	
	}
	pResult->hidResult= HIDResult_CANErr;
	return NULL;
	VMProtectEnd();
}

void CHIDWork::UpdateDevice( byte* pBuf,CInteractionData* pResult,CProgressCtrl* pProgress)
{
	VMProtectBegin("HIDWork14");
	unsigned int i,k;
	unsigned char JL=0;
	unsigned int Length;
	unsigned char Ads_U=0x00;
	unsigned char Ads_H=0x10;//0x60
	unsigned char Ads_L=0x00;

	CString StrName;
	int len;
	DWORD totalLen=0;
	DWORD BufLen=0;
	DWORD TmpLen=0;

	len = 0;
	//
	unsigned int BUF_A,BUF_B;
	//
	unsigned j;
	unsigned char temp;
	unsigned char N;
	unsigned char Carry;
	unsigned char pDtOut[2];
	//
	unsigned char T0,T1,T2,T3;

	T0=pBuf[0x7000]-HexID[0];
	T1=pBuf[0x7001]-HexID[1];
	T2=pBuf[0x7002]-HexID[2];
	T3=pBuf[0x7003]-HexID[3];
	CString strTemp,strTemp1;
	if((0!=T0)||(0!=T1)||(0!=T2)||(0!=T3))
	{
		MessageBox(_T("文件与设备不匹配!!"),_T("Error"),MB_OK);
		return;
	}

	BUF_A=pBuf[0x7004]*0x100+pBuf[0x7005];
	BUF_B=HexVer[0]*0x100+HexVer[1];
	if(BUF_A<BUF_B)
	{
		MessageBox(_T("文件版本低于设备版本!!"),_T("Error"),MB_OK);
		return;
	}
	//-->
	pDtOut[0]=0x00;		//CRC_HI
	pDtOut[1]=0x00;		//CRC_LO
	for(i=0;i<0x700E;i++)
	{
		temp=pBuf[i];
		for(j=0;j<8;j++)
		{
			N=0x80 & temp;
			pDtOut[0]=pDtOut[0]^N;
			if((pDtOut[0]&0x80)==0x80)
			{
				pDtOut[0]=pDtOut[0]^0x08;
				pDtOut[1]=pDtOut[1]^0x10;
				Carry=0x80;
			}
			else
			{
				Carry=0x00;
			}
			pDtOut[0]=pDtOut[0]<<1;
			if((pDtOut[1]&0x80)==0x80)
			{
				pDtOut[0]=pDtOut[0]|0x01;
			}
			else
			{
				pDtOut[0]=pDtOut[0]&0xFE;
			}

			pDtOut[1]=pDtOut[1]<<1;
			if((Carry&0x80)==0x80)
			{
				pDtOut[1]=pDtOut[1]|0x01;
			}
			else
			{
				pDtOut[1]=pDtOut[1]&0xFE;
			}
			temp=temp<<1;
		}
	}

	T0=pBuf[0x700E] - pDtOut[0];
	T1=pBuf[0x700F] - pDtOut[1];
	//if((pBuf[0x700E]!=pDtOut[0])||(pBuf[0x700F]!=pDtOut[1]))
	if((0!=T0)||(0!=T1))
	{
		MessageBox(_T("文件校验错误!!"),_T("Error"),MB_OK);
		return;
	}
	//--^


	//
//	Check_mima();
//	if(FALSE==ChkResult)
//	{
//		MessageBox("授权信息错误!!","Error",MB_OK);
//		return;
//	}	
	//MessageBox("开始升级!!","警告",MB_OK);

//	if (IDYES==MB_OK)
//	{
//	}
	CInteractionData tx;
	CInteractionData rx;
	//--
	k=0;
	Length=0x7000;//
	pProgress->SetRange(0,0x380);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	int pPos=0;
	while(Length!=0x00)
	{
		Length-=0x20;
		tx.Init();
		tx.buff[0] = 0x01;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		if(JL==0)
		{
			tx.buff[5]=0x00;	//操作的地址，L,送数据时仅用一个地址字节
		}
		else
		{
			tx.buff[5]=0x20;	//操作的地址，L,送数据时仅用一个地址字节
		}	

		for(i=0;i<0x20;i++)
		{
			tx.buff[i+0x10]=pBuf[k++];
		}
		
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		//每传送两串数据，发一次写命令，设备把数据写入内部FLASH
		JL++;
		if(2==JL)
		{
			JL=0;
			//--data cal
			tx.Init();
			tx.buff[0]=0x02;
			rx = DeviceInteraction(tx);
			if (!rx.bOK)
			{
				pResult->hidResult= HIDResult_USBError;
				return;
			}
			else if (rx.CheckDataList() == false)
			{
				pResult->hidResult= HIDResult_RxError;
				return;
			}
			tx.Init();
			tx.buff[0]=0x05;
			tx.buff[1]=0x55;
			tx.buff[5]=Ads_L;
			tx.buff[6]=Ads_H;
			tx.buff[7]=Ads_U;
			rx = DeviceInteraction(tx);
			if (!rx.bOK)
			{
				pResult->hidResult= HIDResult_USBError;
				return;
			}
			else if (rx.CheckDataList() == false)
			{
				pResult->hidResult= HIDResult_RxError;
				return;
			}
			Ads_L+=0x40;
			if(0x00==Ads_L)
			{
				Ads_H++;
			}
		}
		pPos++;
		pProgress->SetPos(pPos);
		pProgress->UpdateWindow();
	}
	tx.Init();
	tx.buff[0]=0x0f;
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		pResult->hidResult= HIDResult_USBError;
		return;
	}
	else if (rx.CheckDataList() == false)
	{
		pResult->hidResult= HIDResult_RxError;
		return;
	}
	pPos++;
	pProgress->SetPos(pPos);
	pProgress->UpdateWindow();
	return;
	VMProtectEnd();
// 	
// 		//*/
// 		Dspdata="Download OK";
// 		SetDlgItemText(IDC_EDIT11, Dspdata);
// 		MessageBox("升级完成","OK",MB_OK);
}

void CHIDWork::WriteVIN(int mode, byte* pBuf,CInteractionData* pResult,CProgressCtrl* pProgress )
{
	int i,j;
	int m=0;

	//第1款--
	const byte CANee_A[0x0E][0x10]={
		//{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		//{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x13,0x3B,0x05,0x00,0x00,0x00,0x00,0x00,0x01},//57,44,44,32
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//30,34,30,35,34,31,52
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//30,31,30,35,36,33,
		{0x09,0x00,0x00,0xBF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0D
	};
	//第2款--
	const byte CANee_B[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x14,0x2E,0x02,0x05,0x00,0x00,0x00,0x00,0x01},//57,44,44
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//32,30,34,30,35,34,31
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//52,30,31,30,35,36,33
		{0x09,0x00,0x00,0x90,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANee_C[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x14,0x2E,0x00,0x05,0x00,0x00,0x00,0x00,0x01},//57,44,44
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//32,30,34,30,35,34,31
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//52,30,31,30,35,36,33
		{0x09,0x00,0x00,0x90,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--
	const byte CANee_D[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x13,0x3B,0x05,0x00,0x00,0x00,0x00,0x00,0x01},//57,44,44,32
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//30,34,30,35,34,31,52
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//30,31,30,35,36,33,
		{0x09,0x00,0x00,0x90,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};
	//第5款
	const byte CANee_E[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x14,0x2E,0x00,0x05,0x00,0x00,0x00,0x00,0x01},//57,44,44
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//32,30,34,30,35,34,31
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//52,30,31,30,35,36,33
		{0x09,0x00,0x00,0xBF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};
	//第7款
	const byte CANee_G[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x14,0x2E,0x00,0x05,0x00,0x00,0x00,0x00,0x01},//57,44,44
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//32,30,34,30,35,34,31
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//52,30,31,30,35,36,33
		{0x09,0x00,0x00,0x90,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};
	//第8款//第9款
	const byte CANee_H[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x14,0x2E,0x00,0x05,0x00,0x00,0x00,0x00,0x01},//57,44,44
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//32,30,34,30,35,34,31
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//52,30,31,30,35,36,33
		{0x09,0x00,0x00,0x90,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//备用,仅接收

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};

	unsigned char rxCK[0x09][0x04]={
		{0x02,0x7B,0x05,0x78},//1-
		{0x03,0x6E,0x02,0x05},//2-
		{0x03,0x6E,0x00,0x05},//3-
		{0x02,0x7B,0x05,0x78},//4-
		{0x03,0x6E,0x00,0x05},//5-
		{0x03,0x6E,0x00,0x05},//6-
		{0x03,0x6E,0x00,0x05},//7-
		{0x03,0x6E,0x00,0x05},//8-
		{0x03,0x6E,0x00,0x05},//9-
	};
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Lnt,JC;
	//	unsigned char LPstart,LPend,LPcnt,STP;
	//	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x0E,0x09,0x0B,0x00,0x00,0x00},//1----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//2----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//3----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//4----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//5----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//6----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//7----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//8----
		{0x0A,0x05,0x07,0x00,0x00,0x00},//9----
	};
	unsigned char rdCK[0x08]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

	k = rdEEDT[mode][0x00];
	Lnt = rdEEDT[mode][0x01];//需要填入的开始行标
	JC = rdEEDT[mode][0x02];//需要检查的行标

	//	LPstart = rdEEDT[mode][0x01];
	//	LPend = rdEEDT[mode][0x02];

	//	STP =  rdEEDT[mode][0x04];
	bool fOK=false;
	bool fRS=false;

	bool fAdd=false;//无需递增
	//	r=mode;
	//-------------------------
	switch(mode)
	{
		//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_A[j][i];
			}
		}
		break;
		//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_B[j][i];
			}
		}
		break;
		//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_C[j][i];
			}
		}
		break;
		//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_D[j][i];
			}
		}
		break;
		//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_E[j][i];
			}
		}
		break;
		//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_G[j][i];
			}
		}
		break;
		//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_H[j][i];
			}
		}
		break;
		//------
		//------
	default:
		pResult->hidResult=HIDResult_CANErr;
		return;
	}
	switch(mode)
	{
		//------
	case 0x00://第1款
	case 0x03://第4款
		j=Lnt;
		for(i=0;i<0x04;i++)
		{
			TMP[j][i+0x0A]=pBuf[0x300+i];
		}
		j++;
		for(i=0;i<0x07;i++)
		{
			TMP[j][i+0x07]=pBuf[0x304+i];
		}
		j++;
		for(i=0;i<0x06;i++)
		{
			TMP[j][i+0x07]=pBuf[0x30B+i];
		}
		break;
		//------
	case 0x01:
	case 0x02:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
		j=Lnt;
		for(i=0;i<0x03;i++)
		{
			TMP[j][i+0x0B]=pBuf[0x300+i];
		}
		j++;
		for(i=0;i<0x07;i++)
		{
			TMP[j][i+0x07]=pBuf[0x303+i];
		}
		j++;
		for(i=0;i<0x07;i++)
		{
			TMP[j][i+0x07]=pBuf[0x30A+i];
		}
		break;
		//------

	default:
		pResult->hidResult=HIDResult_CANErr;
		return;
	}
	//--//--P 可用作进度条变量
	bool fSTP=false;//
	P=0;
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	while(false==fSTP)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		tx.buff[0x0F]=0x06;//在09命令字下，自动有效300毫秒，其他忽略

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		Rx=tx.buff[0x1F];
		fAdd=true;//默认递增
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;			
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
				fAdd=false;//无需递增
			}
			//
			if((P==JC)||(P==JC+1))//需要检查的行，
			{
				fRS=true;
				for(i=0;i<0x04;i++)
				{
					if(rxCK[mode][i]!=rx.buff[i+0x10])//BufInput[i+0x10]),i从0到7，8字节为收到的数据；
					{
						fRS=false;
					}
				}
				if(false==fRS)//判断是否检测到有效数据
				{
					fAdd=true;//递增//没检测到一致的数据，P要加1，指向下一个接收或关闭CAN的命令行
				}
				else
				{
					fOK=true;//收到有效数据的标识
					fAdd=false;//不递增,直接设定P的值
					P=k-1;//指向最后一行，关闭CAN的命令行
				}
			}
			//---
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				//此处为第一种波特率失败的情况，默认递增，所以注释掉，这样就进入了第二种波特率的数据发射
				//P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					//DspRead="Read Error TST";
					//SetDlgItemText(IDC_EDIT11, DspRead);
					////MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_ReadEZSError6;
					return;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error TST 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult=HIDResult_ReadEZSError6;
						return;
					}
					else
					{
						fAdd=false;//无需递增,握手包，没握手成功不递增
					}
				}
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=k)
			{
				fSTP=true;//发送关闭CAN命令，跳出循环
			}
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		//------------------
	}
	pProgress->SetPos(k);
	pProgress->UpdateWindow();
	//------------------
	if(true==fOK)
	{
		pResult->hidResult=HIDResult_OK;
	}
	else
	{
// 		DspRead="Write ERROR";
// 		SetDlgItemText(IDC_EDIT11, DspRead);
		pResult->hidResult=HIDResult_CANErr;
	}
	VMProtectEnd();
}
byte* CHIDWork::ECUReadData(CProgressCtrl* pProgress,CInteractionData* pResult,bool* fEcuMd)
{
	VMProtectBegin("HIDWork_ECUReadData");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;

	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0,cntB=0;

	//	const unsigned char FZa[0x08]={0x03,0x7F,0x10,0x12,0x00,0x00,0x00,0x00};//马牌
	//	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//西门子
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_ECU[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		//	{0x08,0x22,0x20,0x85,0x20,0x08,0x43,0x76,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//01
		{0x08,0x22,0x20,0x20,0x20,0x08,0x43,0x76,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//01

		//----
		{0x01,0x60,0x40,0x37,0x20,0x08,0x43,0x76,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//02//加入循环值00--0B,09位置
		{0x0A,0x60,0x40,0x37,0x20,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//03//纯接收，收到4C忽略，05存储
		{0x0A,0x60,0x40,0x37,0x20,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//04//纯接收05忽略，超时没收到即代表发送结束
		//----<
		{0x0A,0x22,0x20,0x20,0x20,0x08,0x43,0x76,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x01},//05

		{0x01,0x22,0x20,0x20,0x20,0x08,0x43,0x76,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//06//加入循环值00--0B,09位置
		{0x0A,0x22,0x20,0x20,0x20,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//07//纯接收，收到4C忽略，05存储
		{0x0A,0x22,0x20,0x20,0x20,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//08//纯接收05忽略，超时没收到即代表发送结束




		//--STOP
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09
	};
	//
	//-------------------------
	//-------------------------
		//---
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x0B);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		if((0x02==P)||(0x06==P))
		{
			RD_ECU[0x02][0x09]=k;
			RD_ECU[0x06][0x09]=k;
		}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_ECU[P][i];
			tptx[i]=RD_ECU[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		}

		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01://
				fAdd=false;//无需递增
				P=0x05;// 正确收到数据代表ECU B
				*fEcuMd=true;//后面擦除的时候需要自动分支识别；

				//	DspRead=" ";//错误退出
				//	SetDlgItemText(IDC_EDIT11, DspRead);

				break;
				//------
			case 0x02://接收4C开头数据，并提取3个字节，
				if(0x4C==tprx[0x00])
				{
					tmpRX[0x10*k+0x00]=tprx[0x05];
					tmpRX[0x10*k+0x01]=tprx[0x06];
					tmpRX[0x10*k+0x02]=tprx[0x07];
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x03://接收并提取5个字节，
				if((0x4C==tprx[0x00])||(0x05==tprx[0x00]))
				{
					if(0x05==tprx[0x00])
					{
						cntA=0;
						tmpRX[0x10*k+0x03]=tprx[0x01];
						tmpRX[0x10*k+0x04]=tprx[0x02];
						tmpRX[0x10*k+0x05]=tprx[0x03];
						tmpRX[0x10*k+0x06]=tprx[0x04];
						tmpRX[0x10*k+0x07]=tprx[0x05];
					}
					else
					{
						fAdd=false;//无需递增
						cntA++;
						if(cntA>0x40)
						{
							cntA=0;
							//	fAdd=false;//无需递增
							P=0x09;
// 							DspRead="read ECU error 03";//错误退出
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							pResult->hidResult= HIDResult_ReadError;
							return NULL;
						}
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 03-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x04://接收05开头数据
				if(0x05==tprx[0x00])
				{
					fAdd=false;//无需递增
					cntA++;
					if(cntA>0x40)
					{
						cntA=0;
						//	fAdd=false;//无需递增
						P=0x09;
// 						DspRead="read ECU error 04";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult= HIDResult_ReadError;
						return NULL;
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 04-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
				//------
			case 0x05:
				if(0x4C==tprx[0x00])
				{
					tmpRX[0x10*k+0x00]=tprx[0x05];
					tmpRX[0x10*k+0x01]=tprx[0x06];
					tmpRX[0x10*k+0x02]=tprx[0x07];
					fAdd=false;//无需递增
					P=0x07;
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 06";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				//------
			case 0x06://接收4C开头数据，并提取3个字节，
				if(0x4C==tprx[0x00])
				{
					tmpRX[0x10*k+0x00]=tprx[0x05];
					tmpRX[0x10*k+0x01]=tprx[0x06];
					tmpRX[0x10*k+0x02]=tprx[0x07];
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 06";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					return NULL;
				}
				break;
				//------
			case 0x07://接收并提取5个字节，
				if((0x4C==tprx[0x00])||(0x05==tprx[0x00]))
				{
					if(0x05==tprx[0x00])
					{
						cntA=0;
						tmpRX[0x10*k+0x03]=tprx[0x01];
						tmpRX[0x10*k+0x04]=tprx[0x02];
						tmpRX[0x10*k+0x05]=tprx[0x03];
						tmpRX[0x10*k+0x06]=tprx[0x04];
						tmpRX[0x10*k+0x07]=tprx[0x05];
					}
					else
					{
						fAdd=false;//无需递增
						cntA++;
						if(cntA>0x40)
						{
							cntA=0;
							//	fAdd=false;//无需递增
							P=0x09;
// 							DspRead="read ECU error 07";//错误退出
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							pResult->hidResult= HIDResult_ReadError;
							return NULL;
						}
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 07-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x08://接收05开头数据
				if(0x05==tprx[0x00])
				{
					fAdd=false;//无需递增
					cntA++;
					if(cntA>0x40)
					{
						cntA=0;
						//	fAdd=false;//无需递增
						P=0x09;
// 						DspRead="read ECU error 08";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult= HIDResult_ReadError;
						return NULL;
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read ECU error 08-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
				//------
			case 0x09:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				fAdd=false;//无需递增
				P=0x02; //超时没收到数据代表ECU A ,
				*fEcuMd=false;//后面擦除的时候需要自动分支识别；
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read ECU overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read ECU overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://
				k++;
				if(k>0x0B)//0x0B
				{
					fOK=true;
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x09;
// 					DspRead="read ECU OK";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					P=0x02;
// 					DspRead="read next";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read ECU overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read ECU overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read ECU overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x08://
				k++;
				if(k>0x0B)//0x0B
				{
					fOK=true;
					fAdd=false;//无需递增
					//fSTP=true;//跳出循环
					P=0x09;
// 					DspRead="read ECU OK";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read next";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x09://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				fSTP=true;//跳出循环
// 				DspRead="read ECU overtime 09";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x09)
			{
				fSTP=true;//超限，跳出循环
			}			
		}
		pProgress->SetPos(k);
		//------------------
	}
	//------------------
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	if(pResult->hidResult==HIDResult_OK)
		return tmpRX;
	else
		return NULL;
	VMProtectEnd();
}
byte* CHIDWork::ECUReadInfo(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork_ECUReadInfo");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;
	
	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0,cntB=0;

	const unsigned char FZa[0x08]={0x02,0x50,0x92,0x00,0x00,0x00,0x00,0x00};//
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_ECU[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x08,0xFC,0x00,0xFD,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//01
		//----
		{0x01,0xFC,0x00,0xFD,0x00,0x08,0x02,0x1A,0x86,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02//ME97
		{0x01,0xFC,0x00,0xFD,0x00,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//03//
		//----<
		{0x01,0xFC,0x00,0xFD,0x00,0x08,0x02,0x1A,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//04//ECU2
		{0x01,0xFC,0x00,0xFD,0x00,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//05//
		//--STOP
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//06
	};
	
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x02);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		//	if((0x02==P)||(0x06==P))
		//	{
		//		RD_ECU[0x02][0x09]=k;
		//		RD_ECU[0x06][0x09]=k;
		//	}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_ECU[P][i];
			tptx[i]=RD_ECU[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		}
		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x08;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read ECU error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read ECU error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x02;
// 					DspRead="read ECU mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x04;//0x0D
// 					DspRead="read ECU mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x02://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x03://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				//	k++;
				fAdd=false;//无需递增
				P=0x06;
// 				DspRead="read ECU A OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
				//------
			case 0x04://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x05:
				for(i=0;i<0x18;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				//	k++;
				fAdd=false;//无需递增
				P=0x06;
// 				DspRead="read ECU B OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
				//------
			case 0x06:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read ECU overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read ECU overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read ECU overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read ECU overtime 04";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read ECU overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="read ECU overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x06)
			{
				fSTP=true;//超限，跳出循环
			}			
		}
		pProgress->SetPos(k);
		//------------------
	}
	pProgress->SetPos(2);
	//------------------
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	if(pResult->hidResult==HIDResult_OK)	
		return tmpRX;
	else
		return NULL;
	VMProtectEnd();
}
void CHIDWork::ECURenew(byte* DS, CProgressCtrl* pProgress,CInteractionData* pResult,bool fEcuMd  )
{
	VMProtectBegin("HIDWork_ECURenew");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	//	unsigned char cntB=0;
	//	const unsigned char FZa[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//02-7G DATA
	//	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xAA,0xAA,0xAA,0xAA,0xAA};//03-7G DATA
	//	bool fRUa=false;
	//	bool fRUb=false;

	//
	//	const unsigned char rdy[0x08]={0x03,0x7F,0x31,0x78,0xFF,0xFF,0xFF,0xFF};// 准备好

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	//unsigned char DS[0x08]={0xAB,0xB7,0x30,0xCD,0xD2,0xA1,0xD3,0x14};//后续通过服务器或界面输入获得数据，暂固定化
	//
	byte RN_ECU[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k

		{0x01,0x60,0x40,0x00,0x00,0x08,0x4A,0x52,0x02,0xE6,0x6D,0x50,0xAA,0xE0,0x00,0x00},//01 --dealer 5bytes,09+
		{0x01,0x60,0x40,0x00,0x00,0x08,0x03,0xF6,0xF3,0x74,0x00,0x00,0x00,0x00,0x00,0x00},//02 --dealer 3bytes,07+
		{0x0A,0x60,0x40,0x37,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x0B,0xFF,0xFF,0x00,0x01},//03

		{0x01,0x22,0x20,0x20,0x20,0x08,0x4A,0x52,0x02,0xE6,0x6D,0x50,0xAA,0xE0,0x00,0x00},//04 --dealer 5bytes,09+
		{0x01,0x22,0x20,0x20,0x20,0x08,0x03,0xF6,0xF3,0x74,0x00,0x00,0x00,0x00,0x00,0x00},//05 --dealer 3bytes,07+
		{0x0A,0x22,0x20,0x20,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x0B,0xFF,0xFF,0x00,0x01},//06
		//
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//07//--STOP
		//----
	};
	//
	//-------------------------	
	//---
	//
	//--
	//--载入DISDEALER
	RN_ECU[0x01][0x09]=DS[0];
	RN_ECU[0x01][0x0A]=DS[1];
	RN_ECU[0x01][0x0B]=DS[2];
	RN_ECU[0x01][0x0C]=DS[3];
	RN_ECU[0x01][0x0D]=DS[4];
	RN_ECU[0x02][0x07]=DS[5];
	RN_ECU[0x02][0x08]=DS[6];
	RN_ECU[0x02][0x09]=DS[7];
	//
	RN_ECU[0x04][0x09]=DS[0];
	RN_ECU[0x04][0x0A]=DS[1];
	RN_ECU[0x04][0x0B]=DS[2];
	RN_ECU[0x04][0x0C]=DS[3];
	RN_ECU[0x04][0x0D]=DS[4];
	RN_ECU[0x05][0x07]=DS[5];
	RN_ECU[0x05][0x08]=DS[6];
	RN_ECU[0x05][0x09]=DS[7];
	//
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x07);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		//	if(0x04==P)
		//	{
		//		RD_GBOX[0x04][0x0B]=k;
		//	}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RN_ECU[P][i];
			tptx[i]=RN_ECU[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
		}

		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				fAdd=false;//无需递增
				if(false==fEcuMd)
				{
					P=0x01;
				}
				else
				{
					P=0x04;
				}
				break;
				//------
			case 0x01://

				break;
				//------
			case 0x02://

				break;
				//------
			case 0x03://
				//fAdd=false;//无需递增
				P=0x07;
				if(0x00==(tprx[0x05]&0x0F))//判断是否擦除OK，字节的低4位来判断，具体规则待探讨
				{
					fOK=true;
					//MessageBox(_T("31"));
					pResult->hidResult= HIDResult_OK;
// 					DspRead="RENEW ECU A OK";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fOK=false;
					//MessageBox(_T("32"));
					pResult->hidResult= HIDResult_RenewError;
// 					DspRead="RENEW ECU A fail";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x04://

				break;
				//------
			case 0x05://

				break;
				//------
			case 0x06://
				//fAdd=false;//无需递增
				P=0x07;
				if(0x00==(tprx[0x05]&0x0F))//判断是否擦除OK，字节的低4位来判断，具体规则待探讨
				{
					fOK=true;
					//MessageBox(_T("61"));
					pResult->hidResult= HIDResult_OK;
// 					DspRead="RENEW ECU B OK";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fOK=false;
					//MessageBox(_T("62"));
					pResult->hidResult= HIDResult_RenewError;
// 					DspRead="RENEW ECU B fail";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x07://
				//fOK=true;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				//	DspRead="read GBOX OK";//错误退出
				//	SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("07"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x07;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("00"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x01://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x07;
// 				DspRead="renew ECU overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("01"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x07;
// 				DspRead="renew ECU overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("02"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				cntA++;
				if(cntA>0x10)
				{
					//fSTP=true;//跳出循环
					P=0x07;
// 					DspRead="renew ECU overtime 03";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox(_T("03"));
					pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
			case 0x04://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x07;
// 				DspRead="renew ECU overtime 04";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("04"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x07;
// 				DspRead="renew ECU overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("05"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				cntA++;
				if(cntA>0x10)
				{
					//fSTP=true;//跳出循环
					P=0x07;
// 					DspRead="renew ECU overtime 06";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox(_T("06"));
					pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
				//------
			case 0x07://
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="renew ECU overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("007"));
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox(_T("08"));
				pResult->hidResult= HIDResult_RenewError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x07)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		//------------------
	}
	VMProtectEnd();
}
byte* CHIDWork::GBoxReadData(CProgressCtrl* pProgress,CInteractionData* pResult)
{
	VMProtectBegin("HIDWork_GBoxReadData");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;
	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//02-7G DATA
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xAA,0xAA,0xAA,0xAA,0xAA};//03-7G DATA
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_GBOX[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xC9,0xE0,0x00,0x00,0x08,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},//01

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x3E,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x00,0xFF,0xFF,0x00,0x01},//04//加入循环值00--0B,0B位置
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//05
		//
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//06//--STOP
		//----
	};	
	//---
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x0b);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		if(0x04==P)
		{
			RD_GBOX[0x04][0x0B]=k;
		}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_GBOX[P][i];
			tptx[i]=RD_GBOX[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
		}
		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01:
				cntA++;
				if(cntA>0x04)
				{
					cntA=0;
				}
				else
				{
					fAdd=false;//无需递增
				}
				break;
				//------
			case 0x02://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x08;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read GBOX error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read GBOX error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x03;
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x03;//
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://暂时不做判断，默认下一步

				break;
				//------
			case 0x04://暂时不做判断，默认下一步

				break;
				//------
			case 0x05://接收21开头数据，并提取8个字节，
				if((0x21==tprx[0x00])&&(0x22==tprx[0x08]))
				{
					tmpRX[0x10*k+0x00]=tprx[0x01];
					tmpRX[0x10*k+0x01]=tprx[0x02];
					tmpRX[0x10*k+0x02]=tprx[0x03];
					tmpRX[0x10*k+0x03]=tprx[0x04];
					tmpRX[0x10*k+0x04]=tprx[0x05];
					tmpRX[0x10*k+0x05]=tprx[0x06];
					tmpRX[0x10*k+0x06]=tprx[0x07];
					tmpRX[0x10*k+0x07]=tprx[0x09];
					//
					k++;
					if(k>0x0B)
					{
						fAdd=false;//无需递增
						fOK=true;
						//fSTP=true;//跳出循环
						P=0x06;
// 						DspRead="read GBOX OK";//错误退出
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
					else
					{
						fAdd=false;//无需递增
						P=0x04;
// 						DspRead="read next";//
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				else
				{
					//fAdd=false;//无需递增
					P=0x06;
// 					DspRead="read GBOX error 05-";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				break;
				//------
			case 0x06://
				//fOK=true;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				//	DspRead="read GBOX OK";//错误退出
				//	SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				//	cntA++;
				//	if(cntA>0x07)
				//	{
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read GBOX overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//	}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read GBOX overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read GBOX overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read GBOX overtime 04";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x06;
// 				DspRead="read GBOX overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="read GBOX overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x06)
			{
				fSTP=true;//超限，跳出循环
			}
			pProgress->SetPos(P);
		}
		pProgress->SetPos(k);
		pProgress->UpdateWindow();
		//------------------
	}
	//------------------
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(tmpRX,0x100);
// 		file.Close();
// 	}
	if(pResult->hidResult==HIDResult_OK)
		return tmpRX;
	else
		return NULL;
	VMProtectEnd();
}

byte* CHIDWork::GBoxReadInfo(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	VMProtectBegin("HIDWork_GBoxReadInfo");
	pResult->hidResult=HIDResult_OK;
	// TODO: Add your control notification handler code here
	int i;

	byte* tmpRX=new byte[0x100];
	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//02-7G DATA
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xAA,0xAA,0xAA,0xAA,0xAA};//03-7G DATA
	bool fRUa=false;
	bool fRUb=false;

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	byte RD_GBOX[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xC9,0xE0,0x00,0x00,0x08,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},//01

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x1A,0x86,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//04
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x1A,0x8F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//05
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//06
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x1A,0x9C,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//07
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},//08
		//
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//09//--STOP
		//----
	};	
	//---
	for(i=0;i<0x100;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x06);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		
		tx.buff[0x0F]=0x06;

		//
		//	if(0x04==P)
		//	{
		//		RD_GBOX[0x04][0x0B]=k;
		//	}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_GBOX[P][i];
			tptx[i]=RD_GBOX[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{}

		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01:
				cntA++;
				if(cntA>0x04)
				{
					cntA=0;
				}
				else
				{
					fAdd=false;//无需递增
				}
				break;
				//------
			case 0x02://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x08;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read GBOX error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x09;
// 					DspRead="read GBOX error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_ReadError;
					return NULL;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x03;
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x03;//
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x04://
				for(i=0;i<0x10;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x05://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x06://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x07://
				for(i=0;i<0x08;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				break;
				//------
			case 0x08://
				for(i=0;i<0x18;i++)
				{
					tmpRX[0x10*k+i]=tprx[i];
				}
				k++;
				fOK=true;
// 				DspRead="read GBOX OK";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			case 0x09://
				//fOK=true;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				//	DspRead="read GBOX OK";//错误退出
				//	SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x01://
				//	cntA++;
				//	if(cntA>0x07)
				//	{
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//	}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x04://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 04";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x08://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x09;
// 				DspRead="read GBOX overtime 08";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
			case 0x09://
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="read GBOX overtime 09";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_ReadError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x09)
			{
				fSTP=true;//超限，跳出循环
			}			
		}
		pProgress->SetPos(k);
		pProgress->UpdateWindow();
		//------------------
	}
	////------------------
	//CFileDialog fileDlgS(FALSE);
	//fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
	//fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
	//fileDlgS.m_ofn.lpstrDefExt="BIN";
	//if (IDOK==fileDlgS.DoModal())
	//{
	//	CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
	//	file.Write(tmpRX,0x100);
	//	file.Close();
	//}
	if(pResult->hidResult==HIDResult_OK)
		return tmpRX;
	else
		return NULL;
	VMProtectEnd();
}

void CHIDWork::GBoxRenew(byte* DS, CProgressCtrl* pProgress,CInteractionData* pResult)
{
	VMProtectBegin("HIDWork_ECURenew");
	// TODO: Add your control notification handler code here
	int i;

	int m;
	int P;
	unsigned char Rx;
	unsigned char cntA=0;
	unsigned char cntB=0;
	const unsigned char FZa[0x08]={0x02,0x50,0x92,0xFF,0xFF,0xFF,0xFF,0xFF};//02-7G DATA
	const unsigned char FZb[0x08]={0x02,0x50,0x92,0xAA,0xAA,0xAA,0xAA,0xAA};//03-7G DATA
	bool fRUa=false;
	bool fRUb=false;

	//
	const unsigned char rdy[0x08]={0x03,0x7F,0x31,0x78,0xFF,0xFF,0xFF,0xFF};// 准备好

	unsigned char tptx[0x20],tprx[0x20];
	unsigned char k=0;

	//unsigned char DS[0x08]={0xE6,0x6D,0x50,0xAA,0xE0,0xF6,0xF3,0x74};//后续通过服务器或界面输入获得数据，暂固定化
	//
	byte RD_GBOX[0x20][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//00//500k
		{0x01,0xC9,0xE0,0x00,0x00,0x08,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},//01

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//02
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x02,0x3E,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//03 //6遍

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x0B,0xFF,0xFF,0x00,0x01},//04
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//05

		{0x01,0x5D,0x60,0x00,0x00,0x08,0x4A,0x52,0x03,0xE6,0x6D,0x50,0xAA,0xE0,0x00,0x00},//06 --dealer 5bytes,09+
		{0x01,0x5D,0x60,0x00,0x00,0x08,0x03,0xF6,0xF3,0x74,0x00,0x00,0x00,0x00,0x00,0x00},//07 --dealer 3bytes,07+

		{0x01,0x22,0x40,0x00,0x00,0x08,0x4A,0x52,0x03,0xE6,0x6D,0x50,0xAA,0xE0,0x00,0x00},//08 --dealer 5bytes,09+
		{0x01,0x22,0x40,0x00,0x00,0x08,0x03,0xF6,0xF3,0x74,0x00,0x00,0x00,0x00,0x00,0x00},//09 --dealer 3bytes,07+

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x0B,0xFF,0xFF,0x00,0x01},//0A

		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x05,0x31,0x43,0x76,0x03,0x0B,0xFF,0xFF,0x00,0x01},//0B
		{0x01,0xFC,0x20,0xFD,0x20,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},//0C
		//
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//0D//--STOP
		//----
	};
	
	//
	//--
	//--载入DISDEALER
	RD_GBOX[0x06][0x09]=DS[0];
	RD_GBOX[0x06][0x0A]=DS[1];
	RD_GBOX[0x06][0x0B]=DS[2];
	RD_GBOX[0x06][0x0C]=DS[3];
	RD_GBOX[0x06][0x0D]=DS[4];
	RD_GBOX[0x07][0x07]=DS[5];
	RD_GBOX[0x07][0x08]=DS[6];
	RD_GBOX[0x07][0x09]=DS[7];
	//
	RD_GBOX[0x08][0x09]=DS[0];
	RD_GBOX[0x08][0x0A]=DS[1];
	RD_GBOX[0x08][0x0B]=DS[2];
	RD_GBOX[0x08][0x0C]=DS[3];
	RD_GBOX[0x08][0x0D]=DS[4];
	RD_GBOX[0x09][0x07]=DS[5];
	RD_GBOX[0x09][0x08]=DS[6];
	RD_GBOX[0x09][0x09]=DS[7];
	//
	//--
	bool fAdd,fOK;//fRS,
	bool fSTP=false;//
	fOK=false;
	m=0x00;
	P=0x00;
	//--m 可用作进度条变量
	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,0x0d);
	pProgress->SetPos(0);
	while(false==fSTP)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		tx.buff[0x0F]=0x06;

		//
		//	if(0x04==P)
		//	{
		//		RD_GBOX[0x04][0x0B]=k;
		//	}
		//
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RD_GBOX[P][i];
			tptx[i]=RD_GBOX[P][i];
		}
		Rx=tx.buff[0x1F];

		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{}
		//--
		for(i=0;i<0x20;i++)
		{
			tprx[i]=rx.buff[i+0x10];
		}
		fAdd=true;//默认递增
		if(0x00==rx.buff[1])
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，
				break;
				//------
			case 0x01:
				cntA++;
				if(cntA>0x04)
				{
					cntA=0;
				}
				else
				{
					fAdd=false;//无需递增
				}
				break;
				//------
			case 0x02://根据收数，判断分支
				fAdd=false;//无需递增
				fRUa=true;
				fRUb=true;
				cntA=0;
				for(i=0;i<0x08;i++)
				{
					if(tprx[i]!=FZa[i])
					{
						fRUa=false;
					}
					if(tprx[i]!=FZb[i])
					{
						fRUb=false;
					}
				}
				if((false==fRUa)&&(false==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x0D;
// 					DspRead="read GBOX error 01";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
					return;
				}
				if((true==fRUa)&&(true==fRUb))
				{
					//fAdd=false;//无需递增
					P=0x0D;
// 					DspRead="read GBOX error 02";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
					return;
				}
				if((true==fRUa)&&(false==fRUb))
				{
					P=0x03;
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode A";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				if((false==fRUa)&&(true==fRUb))
				{
					P=0x03;//
					//	fAdd=true;//递增
// 					DspRead="read GBOX mode B";//错误退出
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fRUa=true;
				cntA++;
				if(cntA>0x04)
				{
					fAdd=true;//递增
					cntA=0;
				}
				break;
				//------
			case 0x04://
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=rdy[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					fAdd=false;//无需递增
					P=0x05;
// 					DspRead="ism ready";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					P=0x0D;
// 					DspRead="ism busy";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				break;
				//------
			case 0x05://

				break;
				//------
			case 0x06://

				break;
				//------
			case 0x07://

				break;
				//------
			case 0x08://

				break;
				//------
			case 0x09://

				break;
				//------
			case 0x0A://
				fRUb=true;
				for(i=0;i<0x04;i++)
				{
					if(tprx[i]!=rdy[i])
					{
						fRUb=false;
					}
				}
				if(true==fRUb)
				{
					fAdd=false;//无需递增
					P=0x0C;//0x0B
// 					DspRead="ism ready";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fAdd=false;//无需递增
					cntB++;
					if(cntB>0x80)
					{
						P=0x0D;
// 						DspRead="ism busy";//
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					}
				}
				break;
				//------
			case 0x0B://

				break;
				//------
			case 0x0C://
				fAdd=false;//无需递增
				P=0x0D;
				if(0x00==(tprx[0x02]&0x80))//判断是否擦除OK，字节的低4位来判断，具体规则待探讨
				{
					fOK=true;
// 					DspRead="RENEW GBOX OK";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				}
				else
				{
					fOK=false;
// 					DspRead="RENEW GBOX fail";//
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult= HIDResult_RenewError;
				}
				break;
				//------
			case 0x0D://
				//fOK=true;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				//	DspRead="read GBOX OK";//错误退出
				//	SetDlgItemText(IDC_EDIT11, DspRead);
				break;
				//------
			default:
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//-----
			}
		}
		else
		{
			switch(P)
			{
				//------
			case 0x00://此包是配置数据，不可能出错

				fAdd=false;//无需递增
				fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="异常错误1!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x01://
				//	cntA++;
				//	if(cntA>0x07)
				//	{
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 01";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//	}
				break;
				//------
			case 0x02://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 02";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x03://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 03";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x04://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 04";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x05://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 05";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x06://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 06";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x07://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 07";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x08://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 08";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x09://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 09";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0A://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 0A";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0B://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 0B";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0C://
				fAdd=false;//无需递增
				//fSTP=true;//跳出循环
				P=0x0D;
// 				DspRead="read GBOX overtime 0C";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
			case 0x0D://
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="read GBOX overtime 0D";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				break;
				//------
				//------
			default:
				fOK=false;
				fAdd=false;//无需递增
				fSTP=true;//跳出循环
// 				DspRead="异常错误2!!";//错误退出
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				pResult->hidResult= HIDResult_RenewError;
				//------
			}
		}
		//--
		if(true==fAdd)
		{
			P++;
			if(P>=0x0D)
			{
				fSTP=true;//超限，跳出循环
			}
		}
		//------------------
	}
	VMProtectEnd();
}